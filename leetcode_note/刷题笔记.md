# 20241112
## Letter Combinations of a Phone Number
[题目链接](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```angular2html
class Solution(object):
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        phone = {"1": [], "2": ['a','b','c'], "3": ['d','e','f'], "4": ['g','h','i'], "5":['j','k','l'], "6":['m','n','o'], "7":['p','q','r','s'],"8":['t','u','v'],"9":['w','x','y','z']}
        
        length_digits = len(digits)
        if length_digits == 0:
            output = []
        elif length_digits == 1:
            output = phone[digits]
        elif length_digits > 1:
            digits_split = list(digits)
            output = []
            if length_digits == 2:
                for i in phone[digits_split[0]]:
                    for j in phone[digits_split[1]]:
                        element = i+j
                        output.append(element)
            elif length_digits == 3:
                for i in phone[digits_split[0]]:
                    for j in phone[digits_split[1]]:
                        for k in phone[digits_split[2]]:
                            element = i+j+k
                            output.append(element)
            elif length_digits == 4:
                for i in phone[digits_split[0]]:
                    for j in phone[digits_split[1]]:
                        for k in phone[digits_split[2]]:
                            for l in phone[digits_split[3]]:
                                element = i+j+k+l
                                output.append(element)
        return output

```

### good solution`
```angular2html
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        
        digit_to_letters = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz',
        }

        def backtrack(idx, comb):
            if idx == len(digits):
                res.append(comb[:])
                return
            
            for letter in digit_to_letters[digits[idx]]:
                backtrack(idx + 1, comb + letter)

        res = []
        backtrack(0, "")

        return res

```
### 学习到的点
1. string可以直接for loop, 如
   ```
   for i in '23':
        print(i)
   ```
   会直接返回'2'和'3', 并不需要先转化为list再for loop
2. 想要把两个string组合到一起直接相加就好， 如 a = 'lala', b='haha', 则 a+b = 'lalahaha'.
3. 我原本不知道怎么根据输入的digits的长度创建对应数量的for循环, 如digits='234', 则长度为3，那就需要3个for循环来构造字母组合, 一如我自己的solution这样。但good solution中通过构造一个函数并在函数内嵌套for循环的方法来实现这个功能，同时设定当idx达到digits的长度时则退出。基本逻辑如下：假设我们的输入 digits = '23'. 最外层调用为 backtrack(0,""), 这时候 idx=0，comb为空。然后if判断显然不成立。接着进入第一个循环, 这时候 for 循环数字 2 对应的所有字母，第一个为 'a', 然后再次调用函数 backtrack(idx + 1, comb + letter), 进入第一个函数嵌套，此时嵌套函数输入实际值为 backtrack(1,'a') . 再次判断if条件，明显 idx == 1 而 len(digits) == 2, 所有if条件不满足，不会加入到最终的返回数组 res 里， 这时候进行嵌套的第二个 for 循环， 这时候 for 循环数字 3 对应的所有字母， 第一个为 'd', 然后再次调用函数 backtrack(idx + 1, comb + letter) 进入第三层嵌套函数，这时函数的输入实际值是 backtrack(2, 'ad'). 进入第三层函数嵌套后，再次进行if判断, 此时满足if条件，则将 'ad' 加入到最终的返回数组 res 里，然后退出第三层函数嵌套，回到第二层函数嵌套。在第二层函数嵌套中，for循环的第二个字母是 'e'， 则重新调用 backtrack(idx + 1, comb + letter) 进入一个新的第三层函数嵌套，此时函数输入是 backtrack(2,'ae'), 同样满足if条件，所有 'ae' 也加入到 res中. 以此类推，当第二层函数嵌套的for循环结束后，自动返回到第一层函数嵌套的 for 循环的下一次 iteration， 数字2 对应的第二个字母是 'b’ 然后调用 backtrack(idx + 1, comb + letter) 重新进入新的第二层函数嵌套， 这时函数输入是 backtrack(1, 'b')， 同理在这个第二层函数嵌套中同样进行三次针对数字 3 对应字母的 循环迭代， 将 'bd', 'be', 'bf' 加入到 res中, 然后又再次回到第一层函数嵌套进行第三轮 'c' 的函数嵌套。通过这种函数和for循环互相嵌套，并且在函数内再次调用函数的方式实现了我不知道怎么解决的问题。


# 20241113

## Generate Parentheses(未做对)
[题目链接](https://leetcode.com/problems/generate-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案是不完整的，当n=4时候，我只能返回12个结果，而正确答案应该返回14个结果
```
class Solution(object):
    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """

        output = []
        def backtrack(n, parenthese_pairs):
            count = n
            while count > 0:
                left_parenthese_element = '('*count
                if count == n:
                    parenthese_pairs_new = parenthese_pairs + left_parenthese_element + n*')'
                    output.append(parenthese_pairs_new)
                    count = count - 1
                else:
                    for i in range(1, count+1):
                        right_parenthese_element = i*')'
                        if len(left_parenthese_element) == len(right_parenthese_element):
                            parenthese_pairs_new = parenthese_pairs + left_parenthese_element + right_parenthese_element
                            backtrack(n-i, parenthese_pairs_new)
                            break
                        parenthese_pairs_new = parenthese_pairs + left_parenthese_element + right_parenthese_element + (n-count)*'(' + (n-i)*')'
                        output.append(parenthese_pairs_new)
                    count = count - 1

            if count == 0:
                return
                    
        backtrack(n, '')

        return output
```


### good solution
```
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []

        def dfs(openP, closeP, s):
            if openP == closeP and openP + closeP == n * 2:
                res.append(s)
                return
            
            if openP < n:
                dfs(openP + 1, closeP, s + "(")
            
            if closeP < openP:
                dfs(openP, closeP + 1, s + ")")

        dfs(0, 0, "")

        return res

```

### 学习到的点

1. 这个题答案用了连续的函数嵌套, 基于存在一个左括号就一定会存在一个右括号的原理，先把左括号加满。在左括号的if条件中连续嵌套函数，然后再依次根据每个左括号的位置加对应的右括号，只要满足当前左括号的数量不小于右括号即可。同样是基于这个条件不停嵌套函数，最底层是只要左括号数等于右括号数且总和小于2n就将生成的括号组合加入到输出中。我的答案太复杂了，只基于一个if条件进行函数嵌套，其实可以学习这个答案，基于多个条件进行嵌套的，这样就不会出现漏掉某种情况的问题。

# 20241122
## Combination Sum

[题目链接](https://leetcode.com/problems/combination-sum/submissions/1459962308/?envType=study-plan-v2&envId=top-100-liked)

### my solution

```
class Solution(object):
    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        output = []
        def find_combination(candidates, target, combination):
            if target == 0:
                combination.sort()
                if combination not in output:
                    output.append(combination)
                return
            min_candidates = min(candidates)
            if target < min_candidates:
                return
            for i in candidates:
                combination_new = combination[:]
                # print('combination_new:{}'.format(combination_new))
                # print('combination:{}'.format(combination))
                combination_new.append(i)
                # print('i:{}'.format(i), 'target:{}'.format(target))
                find_combination(candidates, target - i, combination_new)

        find_combination(candidates, target, [])
        return output
```

### good solution

```
class Solution(object):
    def __init__(self):
        self.res = []
        self.path = []

    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        def backtracking(total,candidates,target,startIndex):
            if total == target:
                self.res.append(self.path[:])
                return
            # if total > target:
            #     return
            for i in range(startIndex,len(candidates)):
                if candidates[i] + total > target:
                    break
                total += candidates[i]
                self.path.append(candidates[i])
                backtracking(total,candidates,target,i)
                total -= candidates[i]
                self.path.pop()
        candidates.sort()  # sort Before backTracking
        backtracking(0,candidates,target,0)
        
        return self.res
```

### 学习到的点
1. 和前几道题类似，也是定义一个函数并在函数内循环调用这个函数
2. 之前不知道为什么第一道题的解答采用了 list_name[:] 这种形式，现在知道了这是为了 deep copy, 当使用了deep copy后，会创建一个新的变量，占用一个新的内存，且对新变量进行改变不会影响原来的变量。而正常我原来使用的 a=b 是shallow copy, 这时候a和b都指向同一个变量，改变a的同时也会改变b。而使用 a=b[:] 则会进行一个deep copy操作，这样改变a的时候不会联动改变b。

# 20241125
## Permutations
[题目链接](https://leetcode.com/problems/permutations/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution(object):
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """

        outputs = []
        def fine_permutation(nums, permutation):
            if len(nums) == 0:
                outputs.append(permutation)
                return
            for i in nums:
                new_permutation = permutation[:]
                new_permutation.append(i)
                new_nums = list(set(nums)-set([i]))
                fine_permutation(new_nums, new_permutation)
            
        fine_permutation(nums,[])
    
        return outputs
```

### 学习到的点
1. 从一个list中减去某部分element
   ```
   list(set(list_1)-set(list_2))
   ```

## N-Queens
[题目链接](https://leetcode.com/problems/n-queens/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution(object):
    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """
        output = []
        matrix = [['.']*n for i in range(n)]
        def backtrack(row, column_of_previous_queen, num_queen, matrix):
            if num_queen == n:
                matrix_copy = ["".join(matrix_row) for matrix_row in matrix]
                output.append(matrix_copy)
                return

            for column in range(n):
                if column in column_of_previous_queen:
                    continue

                queen_indicator = True
                new_queen_x = row - 1
                new_queen_y = column - 1
                while new_queen_x>=0 and new_queen_y >=0:
                    if matrix[new_queen_x][new_queen_y] == 'Q':
                        queen_indicator = False
                    new_queen_x = new_queen_x -1
                    new_queen_y = new_queen_y -1
                    
                new_queen_x = row - 1
                new_queen_y = column + 1
                while new_queen_x>=0 and new_queen_y <n:
                    if matrix[new_queen_x][new_queen_y] == 'Q':
                        queen_indicator = False
                    new_queen_x = new_queen_x -1
                    new_queen_y = new_queen_y +1 

                if queen_indicator == True:
                    matrix_new = matrix[:]
                    matrix_new[row][column] = "Q"
                    
                    column_of_previous_queen_new = column_of_previous_queen[:]
                    column_of_previous_queen_new.append(column)

                    num_queen_new = num_queen + 1
                    backtrack(row+1,column_of_previous_queen_new, num_queen_new, matrix_new)
                    matrix_new[row][column] = "."
                    
                    
        backtrack(0,[], 0, matrix)     

        return output
        
```

### good solution
```
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        cols = set()
        posdig = set()
        negdig = set()
        
        res = []
        
        board = [["."]*n for i in range(n)]
        
        def backtrack(r):
            
            if r==n:
                copy = ["".join(row) for row in board]
                res.append(copy)
                return
            
            for c in range(n):
                
                if c in cols or (r+c) in posdig or (r-c) in negdig:
                    continue
                    
                cols.add(c)
                posdig.add(r+c)
                negdig.add(r-c)
                board[r][c]="Q"
                
                backtrack(r+1)
                
                cols.remove(c)
                posdig.remove(r+c)
                negdig.remove(r-c)
                board[r][c]="."
                
        backtrack(0)
        return res
```

### 学习到的点

1. string 乘 int 可以构造连续的 string， 如 '.' * 5 = '.....'
2. join(list)函数可以把list中的element聚合起来，如 ' '.join([I,love,you]) = 'I love you', ''.join([x,x,x,x,x]) = 'xxxxx'.
3. list无法像numpy那样在一个方框内连续引用，如:
```
a = numpy.array([[1,2],[3,4],[5,6]])
b = [[1,2],[3,4],[5,6]]

则 a[0,1]不会报错 而 b[0,1]会报错，只能用b[0][1]

且list好像不支持直接提取列，如 a[:,0] 会返回 array([1,3,5]) 而 b[:,0]会报错

```
4. 要判断对角线上只存在单独的element，可以看出左上到右下的对角线上的element的 x-y 的值是相等的，同时左下到右上的对角线上的element的 x+y 的值是相等的，具体可以看这个[链接](https://leetcode.cn/problems/eight-queens-lcci/solutions/411529/liang-chong-shi-xian-xiang-xi-tu-jie-mian-shi-ti-2/), 因此只需要通过计算 x-y 和 x+y 并保证其他的element不会存在相同的值即可保证对角线上的独立element.
5. 除了list之外，还可以学习 good solution 中使用的 set()，set会将element保存为{1,2,3}的格式，并通过 set_name.add() 和 set_name.remove()实现element的加和减。
6. 本题在backtrack可以针对每一行进行，因为每一行只会存在一个queen, 所以在每一行遍历所有列来创建queen并进入下一层函数嵌套来判断是否符合条件。
7. 连续的string是无法直接添加或者减少元素的，如'aaaabbbb'无法直接将其中一个a替换成c以实现'aaacbbbb'，good solution是将他们构建为 
```
[[a],[a],[a],[a],[b],[b],[b],[b]]
```
的形式再用 
```
''.join([[a],[a],[a],[a],[b],[b],[b],[b]])
```
来将他们转化回 'aaaabbbb'. 我的答案中借鉴了这个方法

# 20241126

## Subsets
[题目链接](https://leetcode.com/problems/subsets/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution(object):
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        
        outputs = []
        def backtrack(subset, nums, outputs):
                
            if subset not in outputs:
                outputs.append(subset)

            if len(nums) == 0:
                return

            for i in nums:
                subset_new = subset[:]
                subset_new.append(i)
                subset_new.sort()
                nums_new = nums[:]
                nums_new.remove(i)

                backtrack(subset_new, nums_new, outputs)

        backtrack([], nums, outputs)

        return outputs
```

### good solution 1
```
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        subset = []
        def dfs(i):
            if i >= len(nums):
                res.append(subset.copy())
                return
            
            subset.append(nums[i])
            dfs(i+1)

            subset.pop()
            dfs(i+1)

        dfs(0)
        return res
```

### good solution 2

```
class Solution:
    def subsets(self, nums):
        result = [[]]  # Start with the empty subset
        for num in nums:
            result += [subset + [num] for subset in result]
        return result
```

### 学习到的点
1. 我的方法虽然也能获得结果，但复杂度太高，属于非常蠢的方法，不能将outputs连同函数进入backtrack过程，会极大地占用计算资源
2. 这道题的本质就是添加和删去现有的元素，在第一个good solution中，先把nums中的每一个元素依次添加到subset集合中，当backtrack层数达到nums总长度时说明没有新的元素可以加入了，就添加到输出集合中。然后紧接着是利用 .pop()函数删去subset中最后一个元素然后再次进入下一层的backtrack，这样就可以跳过删去的那个element来添加新的element了。如当nums = [1,2,3,4]时, 原本[1,2,3]进入下一层后会添加4变为[1,2,3,4], 然后[1,2,3,4]会被添加给outputs并返回上一层函数，并执行[1,2,3].pop()变为[1,2]，然后再进入下一层添加4变为[1,2,4]并加给outputs. list_name.pop()函数是用于删去指定位置的element的，若无指定位置则删去最后一个。
3. good solution2则是一个炫技之作，在每次便利到nums的一个元素时，会将这个元素加到现有的result中的所有集合中并生成新的result. 如一开始是空集合[],遍历到1时变成[[],[1]],遍历到2时变成[[],[1],[2],[1,2]],遍历到3时变成[[],[1],[2],[1,2],[3],[2,3],[1,2,3]]


## Word Search
[题目链接](https://leetcode.com/problems/word-search/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution(object):
    def exist(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        output = []
        def backtrack(word, last_alphabet_position, previous_alphabet_position, iteration):
            # print(iteration)
            
            if len(output) != 0:
                return
            if len(word) == 0:
                output.append('true')
                return

            alphabet = word[0]
            # print(alphabet)

            length_row_board = len(board)
            length_column_board = len(board[0])

            find_alphabet_position = False
            alphabet_position = []
            if last_alphabet_position == [] and iteration == 0:
                first_alphabet_position = []
                for i in range(length_row_board):
                    for j in range(length_column_board):
                        first_alphabet_position = []
                        find_alphabet_position = False
                        if board[i][j] == alphabet:
                            first_alphabet_position.append([i,j])
                            find_alphabet_position = True
                        
                        if find_alphabet_position == True:
                            # print(first_alphabet_position)
                            new_word = word[:0] + word[(0+1):]
                            # print(new_word)
                            previous_alphabet_position.append(first_alphabet_position[0])
                            backtrack(new_word, first_alphabet_position, previous_alphabet_position, iteration+1)
                            previous_alphabet_position.remove(first_alphabet_position[0])
                            
                        

                if find_alphabet_position == False:
                    if len(output) == 0:
                        output.append('false')
                    return
                
            else:
                
                neg_x_position = last_alphabet_position[0][0] - 1
                pos_x_position = last_alphabet_position[0][0] + 1
                neg_y_position = last_alphabet_position[0][1] - 1
                pos_y_position = last_alphabet_position[0][1] + 1

                # print('neg_x_position: {}'.format(neg_x_position), 'pos_x_position: {}'.format(pos_x_position))
                # print('neg_y_position: {}'.format(neg_y_position), 'pos_y_position: {}'.format(pos_y_position))

                if neg_x_position > 0 :
                    if board[neg_x_position][last_alphabet_position[0][1]] == alphabet and [neg_x_position, last_alphabet_position[0][1]] not in previous_alphabet_position:
                        find_alphabet_position = True
                        alphabet_position.append([neg_x_position,last_alphabet_position[0][1]])

                if pos_x_position < length_row_board:
                    if board[pos_x_position][last_alphabet_position[0][1]] == alphabet and [pos_x_position, last_alphabet_position[0][1]] not in previous_alphabet_position:
                        find_alphabet_position = True
                        alphabet_position.append([pos_x_position, last_alphabet_position[0][1]])

                if neg_y_position > 0:
                    if board[last_alphabet_position[0][0]][neg_y_position] == alphabet and [last_alphabet_position[0][0], neg_y_position] not in previous_alphabet_position:
                        find_alphabet_position = True
                        alphabet_position.append([last_alphabet_position[0][0], pos_y_position])

                if pos_y_position < length_column_board:
                    if board[last_alphabet_position[0][0]][pos_y_position] == alphabet and [last_alphabet_position[0][0], pos_y_position] not in previous_alphabet_position:
                        find_alphabet_position = True
                        alphabet_position.append([last_alphabet_position[0][0], pos_y_position])

                if find_alphabet_position == True:
                    new_word = word[:0] + word[(0+1):]
                    # print(new_word)
                    # print(alphabet_position)
                    previous_alphabet_position.append(alphabet_position[0])
                    backtrack(new_word, alphabet_position, previous_alphabet_position, iteration+1)
                # else:
                #     output.append('false')
                    # return 
                        
        backtrack(word, [], [], 0)

        return output[0] == 'true'
```

### good solution
```
class Solution:
    def exist(self, board, word):
        def backtrack(i, j, k):
            if k == len(word):
                return True
            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
                return False
            
            temp = board[i][j]
            board[i][j] = ''
            
            if backtrack(i+1, j, k+1) or backtrack(i-1, j, k+1) or backtrack(i, j+1, k+1) or backtrack(i, j-1, k+1):
                return True
            
            board[i][j] = temp
            return False
        
        for i in range(len(board)):
            for j in range(len(board[0])):
                if backtrack(i, j, 0):
                    return True
        return False
```

### 学习到的点
1. 我把变量命名太长了，这样会导致代码很长
2. good solution 直接将 backtrack 基于每个不同的条件融入到每一层中，如寻找当前element临近的element是否符合条件的时候就是一个位置一个backtrack()函数，而不是像我一样弄了一大堆的if条件判断，同时判断位置是否符合棋盘的范围完全可以在下一层的backtrack()函数中进行，而我就一定要在一层内判断完，这样相比之下我的代码就很蠢。
3. 每一个字母判断完后，good solution直接将这个位置的字母变为空，这样就保证不会重复回到原来的位置，当结束当前backtrack之前才替换回去，相比之下我又弄了一个数组去存储所有对应字母的位置，这无疑加大了对于内存的消耗，以后要避免这种情况再次出现!!!
4. good solution 直接返回 True 和 False, 而我搞了一个 string， 蠢！！！
5. 最初始的第一个字母的搜索完全可以直接用一个最外层的backtrack()函数来完成，而我又是弄了一个if条件来判断，太蠢了。


# 20241127

## Palindrome Partitioning
[题目链接](https://leetcode.com/problems/palindrome-partitioning/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution(object):
    def partition(self, s):
        """
        :type s: str
        :rtype: List[List[str]]
        """
        outputs = []

        def backtrack(palindrome, s):
            
            if len(s) == 0:
                outputs.append(palindrome[:])
                return
            for i in range(len(s)):
                subset = s[0:i+1]  
                if subset == subset[::-1]:
                    palindrome = palindrome[:]
                    palindrome.append(subset)
                    backtrack(palindrome, s[i+1:])
                    palindrome.pop()

        backtrack([], s)

        return outputs
```

### good Solution
```
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        # s = "aab|"
        # a, ab -> No
        # a, b, c -> Yes
        # aa, b -> Yes
        # aab -> No
        # [[a, b, c], [aa, b]] -> Output
        # SOLUTION
        # TC: 2^N
        # SC: 2^N

        result = []
        lenS = len(s)

        def explore(index, curr):
            if index >= lenS:
                result.append(curr.copy())

            for i in range(index, lenS):
                subStr = s[index:i + 1]
                if subStr == subStr[::-1]:
                    curr.append(subStr)
                    explore(i + 1, curr)
                    curr.pop()

        explore(0, [])
        return result
```

### 学习到的点
1. 对于一个list或者string, string_name[::-1]可以实现从后往前输出, 如 'abc'[::-1] = 'cba'
2. 我的答案消耗了相对多的时间，我想这是因为我把s输入到了每一层backtrack中去，这会导致额外的内存占用，实际上只需要像good solution一样指定一个表示当前位置的index并用于调用s中对应的element即可，单个index占用内存肯定小于整个集合。


## Median of Two Sorted Arrays

[题目链接](https://leetcode.com/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:

        nums_merge = nums1 + nums2 
        nums_merge.sort()

        if len(nums_merge)/2 > int(len(nums_merge)/2):
            median = nums_merge[int(len(nums_merge)/2)]
        else:
            median = (nums_merge[int(len(nums_merge)/2)-1] + nums_merge[int(len(nums_merge)/2)])/2

        return median
```

### 学习到的点:
1. python 的int()是向下取整, python3的int()是向上取整。


# 20241128
## Search in Rotated Sorted Array
[题目链接](https://leetcode.com/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
太简单了以至于不需要good solution
```
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        find_target = False
        for i in range(len(nums)):
            if nums[i] == target:
                find_target = True
                target_index = i
        if find_target == False:
            target_index = -1

        return target_index
```

### 学习到的点
1. 虽然代码中没用到。但还是值得一记。返回一个list中特定元素的index可以用函数 list_name.index(target_element)

## Find First and Last Position of Element in Sorted Array
[题目链接](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/1465211714/?envType=study-plan-v2&envId=top-100-liked)

### my solution
同样太简单了所以不需要good solution
```
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:

        find_first_target = False
        find_last_target = False
        number_of_target = 0

        if len(nums) == 1:
            if nums[0] == target:
                find_first_target = True
                find_last_target = True
                first_target_index = 0
                last_target_index = 0
        else:
            for i in range(len(nums)):
                if nums[i] == target:
                    if find_first_target == False:
                        find_first_target = True
                        first_target_index = i
                        number_of_target = number_of_target + 1
                    else:
                        find_last_target = True
                        last_target_index = i
                        number_of_target = number_of_target + 1
        if find_first_target == False:
            first_target_index = -1
        if find_last_target == False:
            last_target_index = -1
        if number_of_target == 1:
            last_target_index = first_target_index
        output = [first_target_index,last_target_index]

        return output
```

### 学习到的点
1. 我一开始忽略了list中只有一个element符合target的情况下 first 和 last 都对应同一个index这种情况


## Search Insert Position
[题目链接](https://leetcode.com/problems/search-insert-position/submissions/1465233661/?envType=study-plan-v2&envId=top-100-liked)

### my solution
题目难度不高，所以没有good solution
```
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:

        find_target = False
        for i in range(len(nums)):
            if nums[i] == target:
                find_target = True
                target_index = i
        if find_target == False:
            nums.append(target)
            nums.sort()
            target_index = nums.index(target)

        return target_index
```

## Search a 2D Matrix

[题目链接](https://leetcode.com/problems/search-a-2d-matrix/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
感觉也是没什么难度，不需要good solution
```
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        find_target = False
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == target:
                    find_target = True
        return find_target
```

# 20241129

## Binary Tree Maximum Path Sum
[题目链接](https://leetcode.com/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
想的复杂了，没做出来

### good solution
```
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        self.max_sum = float("-inf")

        def max_gain(node):
            if not node:
                return 0
            
            left_gain = max(max_gain(node.left),0)
            right_gain = max(max_gain(node.right),0)

            current_sum = node.val + left_gain + right_gain
            self.max_sum = max(self.max_sum,current_sum)

            return node.val + max(left_gain,right_gain)
        
        max_gain(root)
        return self.max_sum
```

### 学习到的点
1. Binary Tree 本质上就是一个节点有往后有两个分支, 当没有分支的时候就结束了，我还考虑什么把一维数组和 Binary Tree 上每一层的节点对应，完全没有这个必要
2. good solution 构造了一个全局变量来记录最大的总和，然后不停地从每个节点的左分支和右分支往后迭代, 每个节点的左右分支都判断是否比0大，比0小说明会照成负收益，就直接忽略。同时每个节点都计算左分支和右分支的收益加当前节点的总和，并和全局变量来做比较。这样当某个节点的值加左右分支的和是最大的时候，就会存储在全局变量中。
3. 分支结束的判断一句就算没有后续节点了
4. 暂时还不清楚怎么把输入的一维数组 root 转化为 形如左右分支的结构的， 可能要和姐夫讨论一下。

## Find Minimum in Rotated Sorted Array
太简单了，不需要回顾

## Binary Tree Inorder Traversal
[题目链接](https://leetcode.com/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
太简单所以不需要good solution
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        self.val = []

        def find_order(node):
            if not node:
                return
            left_node = find_order(node.left)
            self.val.append(node.val)
            right_node = find_order(node.right)
            
        
        find_order(root)

        return self.val

```

## Validate Binary Search Tree
[题目链接](https://leetcode.com/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没做对！！！！
我的答案一开始没有考虑到跨维度的节点之间仍然要满足限制条件的情况, 如 [5,4,6,null,null,3,7]中3是右边分支的第二维的左分支，但这个位置也要满足大于最初始的5，所以这时要返回 False, 而我一开始的代码没有考虑到这个情况。后来报错之后，也找不到怎么样可以用一个更好的方法来传递这个比较的变量，因为我的逻辑是从底层往回传的。

### good solution
```
class Solution:
    res=True
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def dfs (r,mx,mn):
            if r.right:
                if r.right.val<=r.val or r.right.val>=mx:
                    self.res =  False

                dfs(r.right,mx ,r.val)
            if r.left:
                if r.left.val>=r.val or r.left.val<=mn:
                    self.res=  False
                dfs(r.left,r.val,mn)

        dfs(root,2**31,-2**31-1)
        return self.res
```


### 学到的东西
1. 我的逻辑估计想错了，我不应该从底层往回return最大最小限制值，而应该直接从顶层往底层在函数的input中输入最大最小范围，
2. 同时 右边分支每一层的最大就应该是输入的最大，而最小则限制为当前节点的值。 同理， 左边分支每一层的最小应该就算输入的最小，而最大限制则为当前节点的值，这样当遇到 [5,4,6,null,null,3,7] 这种情况时，先右边分支再左边分支，就可以将初始的节点值 5 传递给所有后续的右边分支作为所有右边分支最小值的限制！！！！
3. 之后再重新做一次这个题！！！！

# 20241130

## Symmetric Tree

### my solution
```
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        self.max_layer = 0
        def calculate_max_layer(nood,j):
            if self.max_layer < j:
                self.max_layer = j
            if nood.right:
                calculate_max_layer(nood.right, j + 1)
            if nood.left:
                calculate_max_layer(nood.left, j + 1)
        calculate_max_layer(root,0)

        self.layer_array = [[] for i in range(self.max_layer+1)]

        def dfs(nood,i):
            if nood is None:
                return
            if i == 0 and ((nood.right is None and nood.left is not None) or (nood.left is None and nood.right is not None)):
                self.unsymetric = True

            if nood.left:
                self.layer_array[i].append(nood.left.val)
            elif nood.left is None:
                self.layer_array[i].append(None)
            dfs(nood.left, i + 1)

            if nood.right:
                self.layer_array[i].append(nood.right.val)
            elif nood.right is None:
                self.layer_array[i].append(None)
            dfs(nood.right, i + 1)


        dfs(root,0)
        self.output = True
        print(self.layer_array)
        for i in range(len(self.layer_array)):
            length = len(self.layer_array[i])

            left_side = self.layer_array[i][:int(length/2):]
            right_side = self.layer_array[i][:int(length/2-1):-1]
            if left_side != right_side:
                self.output = False
            
        
        return self.output
```

### good solution

```
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        return self.isMirror(root.left, root.right)

    def isMirror(self, t1: Optional[TreeNode], t2: Optional[TreeNode]) -> bool:
        if not t1 and not t2:
            return True
        if not t1 or not t2:
            return False
        return (t1.val == t2.val and
                self.isMirror(t1.left, t2.right) and
                self.isMirror(t1.right, t2.left))
```

### 学到的东西
1. my solution 是用了一个取巧的方法，又是传统的创建数组存储然后再比较那一套，这样会导致内存的额外占用。
2. 我一开始不知道怎么解决同时验证左分支和右分支的问题。
3. good solution 采用在函数中直接输入左右分支，然后左分支的左子分支和右分支的右子分支比较，左分支的右子分支和右分支的右子分支进行比较。然后往后迭代。

# 20241202

## Binary Tree Level Order Traversal
[题目链接](https://leetcode.com/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution

```
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        self.max_layer = 0
        def calculate_max_layer(nood,j):
            if nood is None:
                return
            if self.max_layer < j:
                self.max_layer = j
            if nood.right:
                calculate_max_layer(nood.right, j + 1)
            if nood.left:
                calculate_max_layer(nood.left, j + 1)
        calculate_max_layer(root,0)

        self.layer_array = [[] for i in range(self.max_layer+1)]

        def dfs(nood,i):
            if nood is None:
                return

            if i == 0:
                self.layer_array[i].append(nood.val)
            if nood.left:
                self.layer_array[i+1].append(nood.left.val)
            dfs(nood.left, i + 1)

            if nood.right:
                self.layer_array[i+1].append(nood.right.val)
            dfs(nood.right, i + 1)

        dfs(root,0)

        if len(self.layer_array[0]) == 0:
            self.layer_array = []

        return self.layer_array
```
        
### good solution
```
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        list1=[]
        q=deque()
        q.append(root)
        while q:
            level=[]
            for i in range(len(q)):
                poping=q.popleft()
                if poping:
                    level.append(poping.val)
                    q.append(poping.left)
                    q.append(poping.right)
            if level:
                list1.append(level)
        return list1
```

### 学到的东西

1. 好多good solution 都用的deque(), 这是python库 collections 中定义的一个类, 可以实现两端操作(即双端队列)。deque()可以实现从队列的头部删去元素(popleft)，也可以从队列的尾部删去元素(pop)。根据评论中的解释, popleft()只会消耗O(1)的时间复杂度, 而使用list并结合pop()会消耗O(n)的时间复杂度。
2. 每轮while循环中, 都会把当前节点从q中提取出来加入到level中并且将左子节点和右子节点加入到q中进入下一轮while循环。


# 20241203

## Maximum Depth of Binary Tree
[link](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution

```
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        self.max_layer = 0
        def calculate_max_layer(nood,j):
            if nood is None:
                return
            if self.max_layer < j:
                self.max_layer = j
            if nood.right:
                calculate_max_layer(nood.right, j + 1)
            if nood.left:
                calculate_max_layer(nood.left, j + 1)
        
        calculate_max_layer(root,0)
        if root is None:
            self.max_layer = -1
        return self.max_layer + 1
```

### good solution
```
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        leftDepth = self.maxDepth(root.left)
        rightDepth = self.maxDepth(root.right)
        return 1 + max(leftDepth, rightDepth)
```

### 学到的东西
1. 我的答案构造了一个额外的变量 self.max_layer 去存储最大的level, 其实可以像 good solution 那样每次运行函数返回最大 level就好了
2. good solution是直接一开始就追踪到最底层, 然后往回回溯的时候每一层level的返回当前深度值都会 +1。这样返回到最顶层时返回值就正好是最大深度.
3. good solution针对 nood = None 的情况是直接返回0, 这正好和正常情况的 return 互相对应了， 而不需要像我那样还要多一个特定的 if条件句来判断。

##  Construct Binary Tree from Preorder and Inorder Traversal
[link](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        self.max_layer = 0
        def find_max_layer(preorder, inorder, layer):
            if len(preorder) == 0:
                if self.max_layer < layer:
                    self.max_layer = layer
            if len(preorder) > 0:
                first_nood = preorder[0]
                index_first_nood = inorder.index(first_nood)
                left_tree = inorder[:index_first_nood]
                right_tree = inorder[index_first_nood+1:]
                
                left_index = [preorder.index(i) for i in left_tree]
                left_index.sort()
                left_preorder = [preorder[j] for j in left_index]
                find_max_layer(left_preorder, left_tree, layer + 1)
                
                right_index = [preorder.index(i) for i in right_tree]
                right_index.sort()
                right_preorder = [preorder[j] for j in right_index]
                find_max_layer(right_preorder, right_tree, layer + 1)

        find_max_layer(preorder, inorder, 0)

        self.layer_array = [[] for i in range(self.max_layer)]

        def construct_tree(preorder, inorder, layer):
            if len(preorder) == 1:
                self.layer_array[layer].append(preorder[0])
                if layer < self.max_layer - 1:
                    diff = self.max_layer - 1 - layer
                    for i in range(diff):
                        for j in range(2*(i+1)):
                            self.layer_array[layer+i+1].append(None)
                    # self.layer_array[layer+1].append(None)
                return
            if len(preorder) > 0:
                first_nood = preorder[0]
                self.layer_array[layer].append(preorder[0])
                index_first_nood = inorder.index(first_nood)
                left_tree = inorder[:index_first_nood]
                right_tree = inorder[index_first_nood+1:]
                
                left_index = [preorder.index(i) for i in left_tree]
                left_index.sort()
                left_preorder = [preorder[j] for j in left_index]
                construct_tree(left_preorder, left_tree, layer+1)
                
                right_index = [preorder.index(i) for i in right_tree]
                right_index.sort()
                right_preorder = [preorder[j] for j in right_index]
                construct_tree(right_preorder, right_tree, layer+1)
        construct_tree(preorder, inorder, 0)
        
        last_array = []
        for i in self.layer_array:
            for j in i:
                last_array.append(j)
        
        return last_array
```

### good solution
```
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:

        preorder = deque(preorder)

        def build(preorder, inorder):
            if inorder:
                idx = inorder.index(preorder.popleft())
                root = TreeNode(inorder[idx])

                root.left = build(preorder, inorder[:idx])
                root.right = build(preorder, inorder[idx+1:])

                return root

        return build(preorder, inorder)
```

### 学到的东西

1. 从good solution 中可以看出，根本不需要像我那样又是算总 layer数又是根据layer数一层层地去创建对应layer array, 直接根据逻辑将 preorder的第一个element作为当前节点, 然后用TreeNode这个class去定义它，然后将其余的左右子分支根据inorder中在当前nood左边的为左子分支, 右边的为右子分支, 迭代调用build函数创建即可。
2. 同样good solution也是一开始就将preorder指定为 deque 双端序列，根据作者解释，这是为了更好的 popping element，因为每一次创建当前 nood 都需要将preorder的第一个element popping出来。

## Convert Sorted Array to Binary Search Tree
[link](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)


### my solution
虽然这是一个easy题目，我也大概想到和上一道可以采用差不多的逻辑，但是我没想到可以直接用self.函数本身 来实现循环调用

### good solution
```
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional['TreeNode']:
        if not nums:
            return None
        mid = len(nums) // 2
        root = TreeNode(nums[mid])
        root.left = self.sortedArrayToBST(nums[:mid])
        root.right = self.sortedArrayToBST(nums[mid + 1:])
        return root
```

### 学到的东西
1. 可以在函数内直接用self.函数本身来实现循环调用

# 20241204

## Flatten Binary Tree to Linked List
[link](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案并不是完全自己想出来的，而是先看了一个答案的长度和循环逻辑，然后在知道存在一个中间变量且整个代码量不大的情况下，再自己把最后的节点互相替代部分补上的
```
class Solution:
    def __init__(self):
        self.prev = None
    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if root is None:
            return None
        
        self.flatten(root.right)
        self.flatten(root.left)

        root.left = None
        root.right = self.prev
        self.prev = root
```

### 学到的东西
1. 没想到可以将节点值大的节点用一个中间变量存储起来，然后将节点值小一点的节点的左边设为None, 节点的右边设为存储起来的节点值

## Binary Tree Right Side View
[link](https://leetcode.com/problems/binary-tree-right-side-view/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案就是最好的答案
```
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        self.max_layer = -1
        self.output = []
        def right_side_view(root, layer):
            if not root:
                return
            if layer > self.max_layer:
                self.output.append(root.val)
                self.max_layer = layer
            right_side_view(root.right, layer+1)
            right_side_view(root.left, layer+1)
        right_side_view(root, 0)

        return self.output
```

## Invert Binary Tree

[link](https://leetcode.com/problems/invert-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if root is None:
            return 
        left_root = self.invertTree(root.left)
        right_root = self.invertTree(root.right)
        
        root.left = right_root
        root.right = left_root

        return root
```

## Kth Smallest Element in a BST
[link](https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        self.all_element = []
        def add_element(node):
            if node is None:
                return
            self.all_element.append(node.val)

            add_element(node.left)
            add_element(node.right)
        
        add_element(root)
        self.all_element.sort()

        return self.all_element[k-1]
        
```

### good solution

```
class Solution(object):
    def kthSmallest(self, root, k):
        self.count = 0
        self.result = 0
        self.inorderTraversal(root, k)
        return self.result
    
    def inorderTraversal(self, node, k):
        if not node or self.count >= k:
            return
        
        self.inorderTraversal(node.left, k)
        
        self.count += 1
        if self.count == k:
            self.result = node.val
            return
        
        self.inorderTraversal(node.right, k)

```

### 学到的东西
1. 我用了一个取巧的方法，就算将所有element都存起来再排序，这样会导致较高的空间占用
2. 像good solution这样，按照binary tree本身的分布逻辑先左分支后右分支地去提取指定第k个node的值会比较节省计算资源。

## Lowest Common Ancestor of a Binary Tree
[link](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案实际上是看了一个good solution的一部分才做出来的，所以严格意义上不算我做出来的，所以这题直接看good solution!!!!!


### good solution
```
class Solution:
  def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
    if not root or root == p or root == q:
      return root

    l = self.lowestCommonAncestor(root.left, p, q)
    r = self.lowestCommonAncestor(root.right, p, q)

    if l and r:
      return root
    return l or r
```

### 学到的东西

1. 其实这道题的目的就是确认某个节点的子分支节点中是否拥有两个指定的节点，当找到指定的节点就是当前迭代到的节点时，就可以直接返回了，因为此时对于上一层节点来说，它的子节点一定包含其中一个指定的节点。同时要注意到，因为是二元分支，所以一个祖先的子节点中如果包含两个指定的节点，那么一定是一个在左分支一个在右分支，或者这个祖先本身就是指定的节点中的一个。
2. 这时候就要分情况讨论了，如果其中一个指定的节点正好就是另一个指定的节点的子节点，那么我们可以直接返回那个祖先节点而不用再追踪那个后辈节点了，因为后辈节点一定在祖先节点的子节点中。
3. 具体到题目一开始举的例子，假设其中一个指定的节点就是最外层的节点 3， 那么我们不用管另一个节点是什么，直接将3作为值返回就行，因为另外一个指定的节点一定是 3 的子节点。
4. 如果两个指定的节点彼此之间没有任何 祖先 和后辈的关系，那么也就意味着他们一定分别来自于某个节点的左右两个分支，所以我们只要我们找到某个节点的左右分支中都分别存在着指定的节点，我们就返回这个节点就好
5. 具体到代码中，可以看到good solution 先判断某个分支是否达到了尽头或者当前节点正好是指定的节点中的一个，如果达到了尽头，说明当前分支中不存在指定的节点，则返回值是None。如果对应指定的节点，则返回值是指定的节点。然后迭代是一个输入左分支进行迭代，一个输入右分支进行迭代。如果返回的左右分支都是指定的节点，则说明指定的节点一定分别在当前节点的左右两个子分支中，对应第四点的情况，那么这个节点就是我们要找的祖先节点。如果只有其中一个返回值是指定的节点，另一个是None, 那么说明当前节点的子节点中只包含一个指定的节点，我们要去寻找当前节点的上一层节点的另外一个分支，这时候就只把指定的节点返回回去而不要返回None,所以代码最后一行 ```return 1 or r``` 的意思是如果不是两个返回值都是指定的节点这种情况，那么只需要返回对应指定节点的那个返回值就好。因为祖先节点的子节点中一定包含另外一个指定节点。
6. example 2中 一个指定的节点4 是另一个指定的节点 5 的子节点，而代码运行到5后发现 5正好是一个指定的节点，就直接将5返回，然后回到 节点3 去搜索节点3的右分支，发现节点4并不存在于节点3的右分支中，那么节点4就一定存在于节点3的左分支中，也就是说节点4一定存在于节点5的两个分支中的一个。这时候节点3的左返回值是节点5，右返回值是None(代表右分支中不存在指定的节点), 那么节点3的最终返回值就是节点5了。 也就是说节点5就一路往回传知道作为最终的输出。
7. 假设 其中一个指定的节点在节点3的左分支中，另一个指定的节点在节点3的右分支中，这时候就会满足左右分支返回值都是节点的情况，那么就说明两个指定的节点正好分别在节点3的左右两个子分支中，那么节点3就是它们的祖先。这时候就根据if条件返回节点3

# 20241205

## Path Sum III

[link](https://leetcode.com/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我有想到是否要加一个指示器表示当前node是否参加了计算，但还是看了答案才确定的， 所以我的答案严格意义上来说也不算完全是自己完成的
```
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        self.output = 0
        def cal_sum(node,target_sum,curr_sum, include):
            if node is None:
                return

            curr_sum = curr_sum + node.val

            if curr_sum == target_sum:
                
                self.output = self.output + 1
        
                
            
            cal_sum(node.left, target_sum, curr_sum, True)
            cal_sum(node.right, target_sum, curr_sum, True)

            if not include:
                cal_sum(node.left, target_sum, 0, False)
                cal_sum(node.right, target_sum, 0, False)
        cal_sum(root,targetSum,0, False)
        
        return self.output
```

### good solution

```
class Solution:
    def pathSum(self, root: Optional[TreeNode], target: int) -> int:
        def dfs(r,t,include):
            if r is None: return 0
            count=0
            if r.val==t: count+=1
            
            count += dfs(r.left,t-r.val,True) + dfs(r.right,t-r.val,True)

            if not include: count += dfs(r.left,t,False) + dfs(r.right,t,False)
            
            return count

        return dfs(root,target,False)
```

### 学到的东西
1. 我自己的答案其实已经完成了绝大部分，但一直由于没办法解决重复调用某组节点组合的问题，导致一直报错。像我原来的答案是没有 ```if not include``` 这个if条件句的，这样就会导致如果有非常深层的节点组合，会被 前两行的 cal_sum() 调用一次，然后再被后两行的 cal_sum() 再调用一次。
2. 我在思考怎么解决的时候有想到是否要加个指示器来保证以每个节点为开始的 和 计算只进行一次，但是是在看了good solution后才完全确定的。 用了一个include来表示当前节点是否参与了 和 计算， 如果为False，则表示 进入下个节点的 curr_sum 为0，即当前节点没有被加到 curr_sum 中，通过这样就保证了以每个节点开始的组合计算不会重复!!!! 


## Diameter of Binary Tree
[link](https://leetcode.com/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        self.max_diameter = 0
        def calc_diameter(node,include):
            if node is None:
                return 0

            left_length = calc_diameter(node.left,True)
            right_length = calc_diameter(node.right,True)


            if self.max_diameter < left_length + right_length:
                self.max_diameter = left_length + right_length
                
            
            return max(left_length,right_length) + 1
        
        calc_diameter(root,False)
        return self.max_diameter     
```

### good solution
```
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        # Define a recursive function to calculate the diameter
        def diameter(node, res):
            # Base case: if the node is None, return 0
            if not node:
                return 0
            
            # Recursively calculate the diameter of left and right subtrees
            left = diameter(node.left, res)
            right = diameter(node.right, res)

            # Update the maximum diameter encountered so far
            res[0] = max(res[0], left + right)
            
            # Return the depth of the current node
            return max(left, right) + 1
        
        # Initialize a list to hold the maximum diameter encountered
        res = [0]
        # Call the diameter function starting from the root
        diameter(root, res)
        # Return the maximum diameter encountered
        return res[0]
```

### 学到的东西
1. 基本上本题的思路就是追踪到每一个分支的最底层，然后往回返回距离，没返回一层就加1，最底层为0，最底层返回倒数第二底层时距离+1变为1。
2. 原来还模仿上一题多加了一组迭代，当include为False时候进入第二组迭代，后来发现并不需要，因为会自动遍历所有的节点而不存在重复问题。
3. 返回值选择左分支和右分支中大的那个加1返回

## Longest Palindromic Substring

### my solution
我的结果虽然是对的，但时间复杂度太高
```
class Solution:
    def longestPalindrome(self, s: str) -> str:
        s_inv = s[::-1]
        max_length = 0
        output=''
        if len(s) <= 1:
            return s
        for i in range(len(s)):
            
            for j in range(len(s) - i):
                str = s[j:j+i+1]
                if str == str[::-1]:
                    if max_length < i+1:
                        output = str
                        max_length = i+1
                
        return output
        
```

### good solution
```
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n=len(s)
        if n==1:
            return s
        res=""
        for i in range(n):
            cur=s[i]
            left,right=i-1,i+1  
            while right<n and s[right]==s[i]:
                cur+=s[i]
                right+=1          
            while left>=0 and right<n and s[left]==s[right]:
                cur=s[left]+ cur +s[left]
                right+=1
                left-=1            
            if len(cur)>len(res):
                res=cur
        return res
```

### 学到的东西
1. 对比我的答案和good solution, 不知道是不是 for循环占用的内存比 while循环多，我的答案逻辑上是蛮直观的反正， good solution虽然占用时间少，但是理解起来难

# 20241207

## Longest Valid Parentheses
[link](https://leetcode.com/problems/longest-valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没做出来，看good solution的答案和笔记

### good Solution 1
stack方法
```
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]  # Base index
        max_length = 0

        for i, char in enumerate(s):
            if char == '(':
                stack.append(i)
            else:
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    max_length = max(max_length, i - stack[-1])
        
        return max_length
```

### good solution 2
Daynamic Programming方法
```
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        dp = [0] * len(s)
        max_length = 0

        for i in range(1, len(s)):
            if s[i] == ')':
                if s[i - 1] == '(':
                    dp[i] = (dp[i - 2] if i >= 2 else 0) + 2
                elif i - dp[i - 1] > 0 and s[i - dp[i - 1] - 1] == '(':
                    dp[i] = dp[i - 1] + (dp[i - dp[i - 1] - 2] if i - dp[i - 1] >= 2 else 0) + 2
                max_length = max(max_length, dp[i])
        
        return max_length
```

### 学到的东西
1. 我一直在想用 左括号表示正数， 右括号表示负数的想法，然后计算有效步长，搞了一大堆的指示器和if条件句，还没成功，属实太傻逼了
2. good solution 1 的主要思想是利用堆栈，每次有一个 左括号，就在堆栈array里添加一个当前的index。 然后每有一个 右括号，就删去堆栈array里的上一个存储的index。这个删去动作分两种情况，第一种情况是上一个存储的index是左括号的index，这时候删去就代表这已经构成了一个完整的括号对，可以从堆栈array中删去了，这样后面计算有效括号数的时候 i-stack[-1] 得到的距离就代表这之间所有有效的括号对组合而成的距离。第二种情况是上一个存储的index是右括号的index，这时候就代表上一轮中右括号的数量比左括号多，所以之前的都是无效的，那我这一轮再加个右括号那还是无效的，举例来说，只要没有左括号，连续3个无效的右括号和连续无效的两个右括号实际都是无效的，而我们只需要知道最后一个无效的右括号的index，到时候出现新的有效的右括号时，计算的时候把有效的右括号index - 最后一个无效的右括号index就可以得到有效的括号对距离。所以这里就把上一个无效的右括号的index删去，再在后面将新的无效的右括号的index添加进去。
3. 当当前迭代到的符号是右括号，且堆栈数组中没有存储任何stack的时候，说明两种情况，要么是刚好上一个右括号正好和最后一个没有匹配的左括号组成了一个有效的括号对然后被从堆栈array中删去了，要么是上一个无效的右括号被直接如第二点中解释的那样被直接删去了，这时候当前迭代的右括号就是一个新的无效的右括号，那就把这个新的无效的右括号的index存进去。
4. 当当前迭代到的符号是右括号且当前stack数组中还包含有之前存储着的index时，说明存储的index要么是上一个还没匹配的左括号的index，要么是上一个无效的右括号的index, 无论哪种情况，有效的括号长度都等于当前index减去堆栈array中存储的最后一个element中的index.
5. good solution 2用的是daynamic programming的方法，具体想法就是创建一个和s一样长度的array，然后每个element存储有效的括号距离。同样是每次循环到右括号的时候，如果上一轮循环的是左括号，则正好构成一个括号对，那动态array同样位置的element中存储的有效括号距离就+2，那如果上一轮循环不是左括号，那么就说明上一轮存储的是右括号，那么上一轮存储的右括号所对应的动态array中的element存储的就是上一轮循环中的有效括号距离，这个距离如果是0，那么就说明上一个右括号是无效的右括号，不构成任何有效的括号对，如果距离大于0，则说明之前已经有对应间距的有效括号，我们要再扣除这个有效的括号距离，然后判断再前一个括号是否是左括号，如果是左括号，则说明又构成一个有效的括号对，这样在当前动态array存储的有效括号距离=上一个动态arrya的element存储的有效括号距离+上一个空闲的左括号前一个动态array存储的有效括号距离+新的括号对代表的2

## Unique Paths
[link](https://leetcode.com/problems/unique-paths/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案就是最好的答案
```
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        grid = [[0]*n]*m
        for i in range(m):
            grid[i][0] = 1
        for j in range(n):
            grid[0][j] = 1
        for k in range(m-1):
            for l in range(n-1):
                grid[k+1][l+1] = grid[k+1][l] + grid[k][l+1]
        
        return grid[m-1][n-1]
```

### good solution
逻辑差不多，都是先创建第一行和第一列全为1，然后后面的element为上和左的element相加
```
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:

        aboveRow = [1] * n

        for _ in range(m - 1):
            currentRow = [1] * n
            for i in range(1, n):
                currentRow[i] = currentRow[i-1] + aboveRow[i]
            aboveRow = currentRow
        
        return aboveRow[-1]
```


## Minimum Path Sum
[link](https://leetcode.com/problems/minimum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案就是最好的答案！！！！
```
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == 0:
                    if j > 0:
                        grid[i][j] = grid[i][j] + grid[i][j-1]
                if j == 0:
                    if i > 0:
                        grid[i][j] = grid[i][j] + grid[i-1][j]

                if i > 0 and j > 0:
                        grid[i][j] = grid[i][j] + min(grid[i][j-1], grid[i-1][j])
        
        return grid[-1][-1]
```
## Climbing Stairs
[link](https://leetcode.com/problems/climbing-stairs/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案就是最好的答案！！！！
```
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2:
            return n
        list = [0]*n
        list[0] = 1
        list[1] = 2
        for i in range(2,n):
            list[i] = list[i-1] + list[i-2]
        
        return list[-1]
```

## Edit Distance

[link](https://leetcode.com/problems/edit-distance/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没做出来！！！！，没想到要创建一个分别以两个string的长度为维度二维矩阵来计算

### good solution
[作者的解释](https://leetcode.com/problems/edit-distance/solutions/3230662/clean-codes-full-explanation-dynamic-programming-c-java-python3/?envType=study-plan-v2&envId=top-100-liked)
```
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m = len(word1)
        n = len(word2)
        # dp[i][j] := min # Of operations to convert word1[0..i) to word2[0..j)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            dp[i][0] = i

        for j in range(1, n + 1):
            dp[0][j] = j

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1

        return dp[m][n]
```
### 学到的东西
1. 根本没想到要创建一个二维矩阵来计算，还在想用老一套的列各种if条件来一步一步推导，傻逼！！！！
2. 作者将word1的长度+1设为二维矩阵的行的维度，将word2的长度+1设为二维矩阵的列的维度，这样就可以将string的每个字母都对应到矩阵中的第一行或第一列上，然后用两个for循环进行word1和word2的每个字母间进行两两的判断，
3. 当在当前格子进行题目中提到的替换，删去和添加其中一个操作时，当前格子的操作数分别对应 ```dp[i - 1][j - 1]```, ```dp[i][j - 1]```,```dp[i - 1][j]```这三个相邻格子的操作数+1
4. 如果两个字母之间是一样的，则表示不需要变化，则将上一对字母匹配所对应的操作数赋给当前格子: ```dp[i][j] = dp[i - 1][j - 1]```。如果两个字母之间不一样，则要选择上面所说的三个相邻格子中所行操作数最小的那一个的基础上进行操作。
5. 最终右下角格子的数字就是最简单的操作数
6. 这道题不需要我真的去把word1替换成word2再在这个过程中计算实际所需的操作数，讲白了脑子里还是没有真正融入daynamic programming的思维！！！！！

## Pascal's Triangle
[link](https://leetcode.com/problems/pascals-triangle/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案就是最好的答案
```
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        output = []
        for i in range(1,numRows+1):
            row = [1]*i
            if i > 2:
                for j in range(i):
                    if j > 0 and j < i-1:
                        row[j] = output[i-2][j-1] + output[i-2][j]
            
            output.append(row)
        
        return output
```


# 20241208

## Word Break

### my solution
我的思路是基于Edit Distance的方法，将wordDict中的每个word都使用Edit Distance的思路和输入的string进行比较, 然后如果匹配成功则从输入的string中删掉当前word。思路感觉上没什么问题，但是对于一些极端情况就很难处理，比如 输入是 ```'ccaccc'``` 而 wordDist中是 ```['cc','ac']```, 这样当我用 ```'cc'```匹配成功后，从 输入的string中删去的是从左至右遇到的cc，即会得到 ```'__a__c'```，而不是 ```'__ac__'```，这样就不符合题目的要求了其实
```
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        output = False
        s_backup = s[:]
        s_indicator = s[:]
        while len(wordDict) > 0:
            for word in wordDict:
                if word not in s_indicator:
                    print('yes')
                    continue
                m = len(s)
                n = len(word)
                dp = [[0] * (n + 1) for _ in range(m + 1)]
                
                for j in range(1, n + 1):
                    for i in range(1, m + 1):
                        if word[j-1] == s[i-1]:
                            dp[i][j] = dp[i-1][j-1] + 1
                
                max_value = 0
                for i in range(1, m + 1): 
                    for j in range(1, n + 1):
                        if max_value < dp[i][j]:
                            max_value = dp[i][j]

                # print(dp)
                # print(s)
                # print(word)
                # print(max_value)
                if max_value == len(word):
                    s_indicator = s.replace(word,'_')
                    s = s.replace(word,'')
                print(s)
                print(s_indicator)
            
            if len(s) == 0:
                output = True
                break
            if len(s) > 0:
                wordDict = wordDict[1:]
                s = s_backup[:]
                s_indicator = s_backup[:]
        
        return output
        
```

### good solution
```
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True
        max_len = max(map(len, wordDict))  # The maximum length of a word in the dictionary

        for i in range(1, n + 1):
            for j in range(i - 1, max(i - max_len - 1, -1), -1): # Only consider words that could fit
                if dp[j] and s[j:i] in wordDict:
                    dp[i] = True
                    break

        return dp[n]
```

### 学到的东西
1. good solution 用的才是正常的 daynamic programming的方法，作者首先创建了一个和输入的string同长度的array作为 动态array来表示输入string的哪一部分可以正好被 wordDist 中的单词表示。
2. 另一个学到的东西是一个 map操作, map(function, object)可以持续地对object里的所有element迭代地执行操作。 good solution 中先用  ```map(len, wordDict)```来计算wordDict中每个word的长度，然后用```max()```来提取最长的长度值
3. 本题的外循环遍历创建的动态array的每个元素, 然后内循环循环从当前外循环遍历到的当前位置 i 往回遍历至word长度的最大值的index, 即假设 i=6，max_len=4, 则 j=5,4,3,2, 当往回遍历的位置对于动态array的element正好是True且输入的string从 i到j 的位置正好对应一个word时候，则可以判断输入string的这一段substring正好对应一个word.
4. 内循环的的```max(i - max_len - 1, -1)```是指当j往回遍历的时候，如果从 i-1 往回走 max_len 得到的值小于 -1，说明当前i所对应的index小于max_len, 假设 max_len=4， 当i=1，2，3的时候就会出现这种情况，这里作者加了一个限制，就是至多往回遍历只能遍历到输入string的开头第一个字母，不会遍历到输入string的结尾字母，所以提取 i - max_len - 1 和 -1 中大的那个, -1就代表结尾最后一个element的index。
5. 作者创建动态array的时候，把第一个element```dp[0]```设置为True, 这样在初始比较的时候，最多能往回遍历到0，即初始位置，然后判断从初始位置往后第几位所代表的substring可以在wordDist中找到对应项。以题目的例子为举例，输入的string为 ```'leetcode'```，wordDist中包含的第一个word是```'leet'```，那么外循环到i=4，j=0的时候就会找到匹配，这时候dp[4]会被设为True。然后再重复这个过程，在 i=8，j=4的时候会再次找到匹配, 然后dp[8]会被设为True并最终作为返回项.

# 20241209

## Maximum Product Subarray
[link](https://leetcode.com/problems/maximum-product-subarray/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我用了太多的循环，其实没必要
```
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0
        if len(nums) == 1:
            return nums[0]
        max_prod = 0
        dp = [0] * len(nums)
        dp[0] = nums[0]
        for i in range(0,len(nums)):
            max_prod = 0
            for j in range(i,-1,-1):
                if i == j:
                    curr_prod = nums[j]
                else:
                    curr_prod = 1
                    for k in range(j,i+1,1):
                        curr_prod = curr_prod*nums[k]

                # print(curr_prod)
                if max_prod < curr_prod:
                        max_prod = curr_prod
            dp[i] = max_prod
        return max(dp)
```

### good solution
```
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        curMax, curMin = 1, 1
        res = nums[0]
        
        for n in nums:
            vals = (n, n * curMax, n * curMin)
            curMax, curMin = max(vals), min(vals)
			
            res = max(res, curMax)
            
        return res
```

### 学到的东西
1. 我有想到要存在复数的情况，即假设前一个是-5，当前是-3，那么-5*-3=15是个很大的值，但我没想到要像good solution那样要用个中间变量 curMin 来存储，然后在每一个循环步骤的时候计算 ```(n, n * curMax, n * curMin)```并提取出最大最小值用于下一轮
2. 我自己的方法在百分之95的例子都适用，报错的原因是超出运算时间限制了，这也很正常，因为我用了三个for循环且每次循环都要重复计算过去的结果，没有用到动态编程的想法，这需要检讨！！！！


## House Robber
[link](https://leetcode.com/problems/house-robber/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
又是没做出来的一题，总是用之前的加一层又一层的for循环和各种if条件去解体，根本不是daynamic programming的思想！！！！！

### good Solution
```
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        
        if n == 1:
            return nums[0]
        
        dp = [0] * n
        
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        
        for i in range(2, n):
            dp[i] = max(dp[i-1], nums[i] + dp[i-2])
        
        return dp[-1] 
```

### 学到的东西
1. 一直没办法真正去使用daynamic programming的思想去考虑， 像这题也是，其实光看答案很简单，就是每一个维度的element+前两个维度存储的值和 前一个维度存储的值做比较。 我思考的时候一直都是想怎么相加怎么相加，设各种条件去相加求最大，没有这种当前元素和之前存储的值做比较的想法。


## Perfect Squares
[link](https://leetcode.com/problems/perfect-squares/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
同样没想出来

### good Solution
```
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        for i in range(1, n + 1):
            min_val = float('inf')
            j = 1
            while j * j <= i:
                min_val = min(min_val, dp[i - j * j] + 1)
                j += 1
            dp[i] = min_val
        return dp[n]
```

### 学到的东西
1. good solution 构造了一个以输入值```n```为长度的list，然后从0开始依次计算到```n```，记录每个点的最小平方数和，这样当进行到后面的大数的时候，大数减去一个整数平方后的值就会自动跳到之前已经被记录的数上。
2. 外循环就是从0到```n```，内循环则是用于寻找最小的整数平方和，从1开始的整数算，当前遍历到的值```i```减去整合平方和正好就会对应到一个已经记录了最小整数平方和的位置，这时候新的潜在的整数平方和就是原来那个位置的整数平方和再+1(因为又加了一个整数平方)，例如遍历到5时，当5减去(1*1)就到4，而4的所需的整数平方和的个数是1(4=2*2), 那么也就是说5只要在dp[4]这个位置记录的所需最小整数平方和的个数上再加上(1*1)这多一个数就等于5的当前所需最小整数平方和的个数。同时构造一个中间变量 ```min_val```来比较每个内循环中计算的所需的整数平方和最小的那个。因为内循环是遍历从1开始到不超过当前```i```值的最大平方数```j```，也就是说j最大可以到 i 的开根号后的sqrt(i)的 整数值，每一个 j 都会通过 ```i - j*j```来追踪到```dp[i - j*j]```上记录的最小所需平方数和的个数再加上```j*j```这一步操作，但是不同的j会计算出不同的所需最小整数平方和的个数，如例子中的 当遍历到 i=12 时，当j = 1时， ```12-1*1```会返回到 dp[11], dp[11]记录的值为3(一个9和两个1)，而当j=2时，```12-2*2```会返回到dp[8]，而dp[8]记录的值为2(两个4)， 这样j=2时候最终获得的值为 3 而 j=1 和 j=3的时候最终获得的值为4， 而 ```min_val = min(min_val, dp[i - j * j] + 1)```就是储存这个内循环中获得的最小所需整数平方和的个数。
3. 讲白了还是不熟练 daynamic programming的思想，没有想到建立从0开始往后推到输入值 n的动态array!!!!!一定要回顾啊

## Longest Increasing Subsequence
[link](https://leetcode.com/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的思路就是用 动态array存储每个element左边比自己小的element的个数，然后返回数值最大的那个element再+1作为返回值。我的答案已经是很好的答案了。
```
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [0]*len(nums)
        for i in range(1,len(nums)):
            lower_max = 0
            for j in range(i-1,-1,-1):
                if nums[i] > nums[j]:
                    lower_count = dp[j] + 1
                    if lower_max < lower_count:
                        lower_max = lower_count
            dp[i] = lower_max
            # print(dp)
            

        return max(dp) + 1
```

# 20241210

## Coin Change
[link](https://leetcode.com/problems/coin-change/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [-1]*(amount+1)
        dp[0] = 0
        if max(coins) > 1000 and len(coins) == 1:
            return -1
        for i in range(1,amount+1):
            min_val = float('inf')
            j = 1
            for j in coins:
                if i-j >= 0:
                    if dp[i-j] == -1:
                        j = j + 1
                        continue
                    val = dp[i-j] + 1
                    if min_val > val:
                        min_val = val
                    if min_val == float('inf'):
                        dp[i] = -1
                    else:
                        dp[i] = min_val
                j = j + 1
        print(dp)
                
        return dp[amount]
```

### good solution
```
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [0] + ([float('inf')] * amount)
        for i in range(1, amount + 1):
            for coin in coins:
                if coin <= i:
                    dp[i] = min(dp[i], dp[i - coin] + 1)

        if dp[-1] == float('inf'):
            return -1
        return dp[-1]
```

### 学到的东西
1. 构造list也可以如good solution那样先指定第一位为某个具体数字然后再加上后续的: ```dp = [0] + ([float('inf')] * amount) ```
2. good solution是把动态array除第一位以外的值都设为正无穷，然后再直接根据类似于我的比较逻辑来将coins中的element和动态array中element作为比较, 即当前动态array的位置减去对应的coin的值返回到之前已经存储的位置，然后再比较当前动态array存储的值和之前存储的值+1哪个比较小，小的存进当前动态array。区别只是我多弄了一个中间量min_val来设为正无穷，而且我的比较大小是分成几个if条件句来进行的，而good solution全合在一起了。这样会减少资源占用。

## Partition Equal Subset Sum
[link](https://leetcode.com/problems/partition-equal-subset-sum/description/?envType=study-plan-v2&envId=top-100-liked)


### my solution
我的答案是错的！！！但我的答案的前半部分和good solution是一致的，都想到了用总和的一半作为目标值创建动态array来判断是否能相加成功。
```
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        all_sum = 0
        for i in nums:
            all_sum = all_sum + i
        if all_sum/2 > all_sum//2:
            return False
        else:
            haft_all_sum = all_sum//2
        dp = [True] + [False] * (haft_all_sum)


        for j in range(1, haft_all_sum+1):
            for k in nums:
                if k <= j:
                    if dp[j - k] == True:
                        dp[j] = True

            
        return dp[-1] 
```

### good solution

```
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        total_sum = sum(nums)
        
        # If the total sum is odd, we can't split it into two equal subsets
        if total_sum % 2 != 0:
            return False
        
        target = total_sum // 2
        dp = [False] * (target + 1)
        dp[0] = True
        
        for num in nums:
            for i in range(target, num - 1, -1):
                dp[i] = dp[i] or dp[i - num]
        
        return dp[target]
```

### 学到的东西
1. 通过for循环nums中的数组来保证nums中的数组在整个整合过程中只被调用一次
2. 每次外循环遍历到其中一个element时，内循环则从最终的总和一半往回遍历，直到遍历到从0开始直接+这个element后能到达的位置(num-1是因为range()函数的结止位置不包括在内，所以```range(target, num - 1, -1)```实际上是从最终的总和的一半往回遍历到```index==num```的位置)，然后每个遍历的位置判断: 是否本位置是可以被总和到(对应当前外循环遍历到的element不参与总和), 或者当前位置减去外循环遍历到的element的位置是否可以被之前的element总和到(对应当前外循环遍历到的element参与总和). 只要这两个中的一个是True, 则说明当前位置是可以被已经遍历到的element集合中的部分或全部元素总和达到。
3. 所以当外循环结束后，如果最末尾(对应全部元素总和的一半)的位置是True, 则说明它可以用nums中的部分元素总和达到全部元素总和的一半的值，那么其余的元素总和肯定就是另外一半了
4. 我自己的答案想到了全部元素总和的一半这个点来建立动态array, 但没想明白怎么来保证每个nums中的元素只被调用一次，现在看来直接for循环nums就可以达到了。good solution中用 ```dp[i] = dp[i] or dp[i - num]```来进行动态array上某个位置的值的赋予的思路值得我参考!!!!!


## Longest Common Subsequence
[link](https://leetcode.com/problems/longest-common-subsequence/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案是在good solution的一些提示才想出来的，我也想到了基于两个string的长度分别作为row和column建立2D动态array并每一行去作比较，但是我一开始设置的全部为False，当满足匹配条件后改为True, 最后再算True的总数，这实际上是很蠢的行为，我一定要排除这种设各种if条件限制并且最后再统计的想法

### good Solution
```
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n=len(text1)
        m=len(text2)
        dp=[[0]*(m+1) for _ in range(n+1)]
        for r in range(1,n+1):
            for c in range(1,m+1):
                if text1[r-1]==text2[c-1]:
                    dp[r][c]=1+dp[r-1][c-1]
                else:
                    dp[r][c]=max(dp[r-1][c],dp[r][c-1])
        return dp[-1][-1]
```

### 学到的东西
1. 像这种返回值是数字的，涉及到两个string的比较之类的，大多情况都要构建二维动态数组且要初始化为数字0，这样就可以利用动态数组的特点，将前半位置记录的值基于不同情况传递给后面的位置
2. 当if条件满足时，说明当前string 1的位置 r上 和 string 2 的位置 c上的字母是匹配的，那这个时候相对于各自string的前一个位置的字母所处的动态array的位置 (r-1,c-1)， 位置(r,c)上匹配的字母数量就比上一个位置的(r-1,c-1)正好多了一个新匹配的字母对。而当字母对不匹配的时候，则把已经匹配的字母对的数量作为当前位置的值，那这个值只会来自于比当前位置之前的位置，有可能是 第一个string的当前字母位置+第二个string的上一个字母位置 或 第一个string的上一个字母的位置+第二个string的当前字母位置 中存储的值， 因为已经匹配的字母对信息只会存储在已经被检索的字母之中，而又因为没有匹配成字母对，所以当前位置 (r,c) 的值要么和 
   - 第一个string的上一个字母和第二个string的当前字母匹配时存储的已经匹配的字母对的数量
   - 第一个string的当前字母和第二个string的上一个字母匹配时存储的已经匹配的字母对的数量
这两种情况中的一种相同。所以选择 最近的那两个位置记录的值的最大的那个作为当前位置的值 ```dp[r][c]=max(dp[r-1][c],dp[r][c-1])```


# 20241212

## Number of Islands
[link](https://leetcode.com/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案虽然也考虑了上下左右四个方向，但是是有局限的，会出现一部分到达边界但另一部分实际没到达边界的情况，而我在其中一部分到达边界的时候就直接默认全部区域都到达边界了，所以我的答案是错误的!!!!! 相比之下， good solution的在每次发现一个 island 时，就将所有访问到的 1 替换成 0，即往四周遍历 island的所有子区域并将遍历到的 island子区域替换成 0 来避免重复访问。
```
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        self.output = 0
        def dfs(i,j, left_bound, right_bound, top_bound, botton_bound):
            print("i: {}".format(i), 'j: {}'.format(j))

            if grid[i][j] == '1':
                if i == 0 or (i >= 1 and grid[i-1][j] == '0') or top_bound == True:
                    top_bound = True
                if i == (len(grid) - 1) or (i < (len(grid) - 1) and grid[i+1][j] == '0') or botton_bound == True:
                    botton_bound = True
                if j == 0 or (j >= 1 and grid[i][j-1] == '0') or left_bound == True:
                    left_bound = True
                if j == (len(grid[0]) - 1) or (j < len(grid[0]) - 1 and grid[i][j+1] == '0') or right_bound == True:
                    right_bound = True

            # print(left_bound, right_bound, top_bound, botton_bound)
            if left_bound and right_bound and top_bound and botton_bound:
                self.output = self.output + 1
                left_bound = False
                right_bound = False
                top_bound = False
                botton_bound = False
            return left_bound, right_bound, top_bound, botton_bound

        left_bound = False
        right_bound = False
        top_bound = False
        botton_bound = False
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                left_bound, right_bound, top_bound, botton_bound = dfs(i,j, left_bound, right_bound, top_bound, botton_bound)

        return self.output
```

### good solution
```
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:

        m = len(grid)
        n = len(grid[0])

        def zero(i,j):

            if (i!=m and i!=-1 and j!=n and j!=-1 and  grid[i][j]=="1"):
                grid[i][j]="0"
                zero(i+1,j)
                zero(i-1,j)
                zero(i,j+1)
                zero(i,j-1)
            
            return

        total =0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "1":
                    total+=1
                    zero(i,j)

        return total   
```

### 学到的东西
1. 一如 my solution中介绍的那样，在good solution的方法中, 当访问到第一个 1 时(即访问到islands某个子区域)后，开始往上下左右四周区域遍历，把遇到的每一个 1 都设为 0， 防止重复访问。


## Course Schedule
[link](https://leetcode.com/problems/course-schedule/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我估计我的答案应该也能跑出来结果，但是就是太复杂导致超出时间限制了
```
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        self.precourses = [[]for i in range(numCourses)]
        self.output = True
        def dfs(course, i):
            if self.output == False:
                return
            if i > 4:
                self.output = False
                return
            # print(i, course, self.precourses)
            # print(self.output)

            if i == 0:
                for j in prerequisites:
                    if course == j[0]:
                        if j[1] in self.precourses[j[0]] or j[0] == j[1]:
                            self.output = False
                        if j[0] not in self.precourses[j[1]]:
                            self.precourses[j[1]].append(j[0])        
            return

        def dfs_2(course,i):
            if self.output == False:
                return
            if i > len(prerequisites):
                self.output = False
                return
            for j in prerequisites:
                if course == j[0]:
                    dfs_2(j[1],i+1)
            return

        for i in range(numCourses):
            dfs_2(i, 0)

        for i in range(numCourses):
            dfs(i, 0)

        return self.output
```

### good solution
```
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = defaultdict(list)      
        in_degree = [0] * numCourses
        q = []
        visited = 0
        for p in prerequisites:
            in_degree[p[1]] += 1
            graph[p[0]].append(p[1])
        for n in range(len(in_degree)):
            if in_degree[n] == 0:
                q.append(n)
        while q:
            n = q.pop(0)
            visited += 1
            for neighbor in graph[n]:
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    q.append(neighbor)
        return numCourses == visited
```

### 学到的东西
1. 作者先遍历所有的 prerequisites 中的element, 将具有 先导课程的那个变量值在 in_degree中的对应位置的element + 1，然后将这个先导关系记录于 graph 中。当遍历完成后， in_degree 中每个位置记录的数字代表 这门课作为其他课程的先导课程的数量。
2. 然后作者将所有没有先导课程身份的数字加入到一个array ```q```中。
3. 然后遍历所有的q，提取q中的每个元素并把这个元素从q中删掉。每遍历一个元素，就将访问次数的指示器 visited + 1. 然后将提取的元素根据 graph中记录的信息去提取他的先导课程，然后将先导课程的维度往下减1，表示找到了一个对应关系，当某个之前具有先导课程身份的数字减到0之后，说明这个数字已经不再有先导课程身份了，就把它加入到 q 中参与遍历
4. 当某几个数字直接构成先导关系时，如 [[0,1],[1,2],[2,0]], 会发现它们没办法参与q的遍历中，因为 0，1，2对应在 in_degree 中的位置不会减少到0。
5. 最后比较 当取消掉所有先导课程的关系后，访问数字的指示器 visited是否和所有课程相等，如果存在4中提到的循环关系，则会有某些数字没有访问到，这样visited就会小于 numCourses.


## Rotting Oranges
[link](https://leetcode.com/problems/rotting-oranges/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没做出来

### good solution
```
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        if not grid: None 

        ROWS, COLS = len(grid), len(grid[0])
        DIRECTIONS = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        visited, queue = set(), deque()
        minutes, fresh_oranges = 0, 0

        # Find Rotten Oranges and Count Fresh
        for r in range(ROWS):
            for c in range(COLS):
                if grid[r][c] == 2:
                    visited.add((r, c))
                    queue.append((r, c))
                elif grid[r][c] == 1:
                    fresh_oranges += 1
        
        # Perform BFS from each Rotten Orange
        while queue and fresh_oranges > 0:
            for _ in range(len(queue)):
                r, c = queue.popleft()
                for dr, dc in DIRECTIONS:
                    row, col = r + dr, c + dc
                    if (row < 0 or row >= ROWS or 
                        col < 0 or col >= COLS or
                        (row, col) in visited or
                        grid[row][col] != 1):
                        continue

                    visited.add((row, col))
                    queue.append((row, col))
                    fresh_oranges -= 1

            minutes += 1

        return minutes if fresh_oranges == 0 else -1

    # O(m * n) time
    # O(m * n) space
```

### 学到的东西:
1. 作者的思路非常清晰，具体可见[link](https://leetcode.com/problems/rotting-oranges/solutions/5041603/bfs-approach-with-full-explanation/?envType=study-plan-v2&envId=top-100-liked)
2. 我没想到四个变化方向可以写入一个array中存储然后在之后用的时候再用for循环遍历
3. 包括我也没想到用两个array: visited 和 queue分别记录坏橘子的信息，一个用来表示坏掉橘子的位置，一个用来表示从坏橘子往外传播的序列。同时作者分别用了 set() 和 deque() 来生成 visited 和 queue。set是因为比list更全面吗？ deque()能明白是为了后续传播的时候用popleft()往外提取element的同时从序列中删去这个element。
4. 我也没想到要用 一个变量记录新鲜橘子的数量，然后在结尾时直接基于这个变量判断是否返回-1
5. 包括后面判断加了方向后的row和column的条件时，我的思想是判断有效的位置，而作者的思想是判断无效的位置，结果我的报错了。明显作者判断无效的位置其余皆有效更为简单


# 20241213

## Jump Game II
[link](https://leetcode.com/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        # save_num = [0] * n
        for i in range(n):
            nums[i] = i + nums[i]
        
        # j = n-2
        min_pos = n-2
        output = 0
        target = n-1
        while target > 0:
            for j in range(target-1,-1,-1):
                if nums[j]>=target:
                    min_pos = min(min_pos,j)
            # output.append(min_pos)
            output = output+1
            target = min_pos

        return output
```

### good solution
```
class Solution:
    def jump(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 0
        res , l , r = 0 , 0 , 0
        while r < len(nums) - 1:
            farthest = 0
            for i in range( l , r + 1 ):
                n = i + nums[i]
                farthest = farthest if farthest > n else n
            l = r + 1
            r = farthest
            res += 1
        return res
```

### 学到的东西
1. 基本逻辑差不多，只是我是从后往前推，good solution是从前往后推
2. good solution占用资源比我的小，可能是因为我多了一个for循环

## Jump Game
[link](https://leetcode.com/problems/jump-game/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
参考 Jump Game II 写的答案，已经是最佳答案了!!!!
```
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums) == 1:
            return True

        l,r,count = 0,0,0
        while count <= len(nums):
            farthest = 0
            for i in range(l,r+1):
                n = i + nums[i]
                farthest = farthest if farthest > n else n
            l = r + 1
            r = farthest
            if r >= len(nums) - 1:
                break
            count = count + 1
        
        # print(farthest)

        if farthest >= (len(nums) - 1):
            return True
        else:
            return False
```

## Best Time to Buy and Sell Stock
[link](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的结果已经很好了
```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_price = float('inf')
        gap = 0
        for i in range(len(prices)):
            if prices[i] < min_price:
                min_price = prices[i]
            if gap < prices[i] - min_price:
                gap = prices[i] - min_price
        
        return gap
```

## Partition Labels
[link](https://leetcode.com/problems/partition-labels/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        str_exit = []
        str_last = [0]*len(s)
        str_first = [0]*len(s)
        for i in range(len(s)):
            if s[i] not in str_exit:
                str_exit.append(s[i])
                str_first[str_exit.index(s[i])] = i
            if s[i] in str_exit:
                alphabet_index = str_exit.index(s[i])
                str_last[alphabet_index] = i
        
        output = []
        last_index = -1
        max_last_index = str_last[0]
        for j in range(len(str_exit)):
            if max_last_index < str_first[j]:
                diff = max_last_index - last_index
                last_index = max_last_index
                output.append(diff)
            if max_last_index < str_last[j]:
                max_last_index = str_last[j]
            if max_last_index == len(s) -1:
                output.append(max_last_index - last_index)
                break
        return output
```

### good solution
```
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        last_occurrence = {char: index for index, char in enumerate(s)}
        
        partitions = []
        start, end = 0, 0

        for i, char in enumerate(s):
            last_index = last_occurrence[char]  
            end = max(end, last_index)  
            
            if i == end:  
                partitions.append(i - start + 1)
                start = i + 1  

        return partitions
```

### 学到的东西
1. 对于一个list或者一串string，可以使用```for index, char in enumerate(s):```来同时提取index信息和index对应的element信息！！！！！
2. good solution 采用 第一点 提到的这个同时提取index和值方法将每个出现的字母和这个字母最后出现的index存储成dictionary的模式，这个方法比我构造两个list，一个用于存字母一个用于存最后出现的index高明多了！！！！学习！！！
3. good solution的第二个循环针对的是输入变量 s, 而且直接在第二个循环中，将每次遍历到的字母的最后出现位置 last_index 和中间变量 end 进行比较， 将大的那个存储成 end, 这其实就是对应我的代码中的
```            
if max_last_index < str_last[j]:
    max_last_index = str_last[j]
```
good solution 这里的方法显然更好，我应该减少if条件的使用

4. 当当前遍历到的位置到达存储的 end 的值时，说明当前位置之前出现的所有字母的最后位置中最大的那个就是当前位置，所以可以分割出一个substring，然后另一个中间变量 start 从下一个位置开始。这个判断其实和我的
```
if max_last_index < str_first[j]:
    diff = max_last_index - last_index
    last_index = max_last_index
    output.append(diff)
```
是一样的

5. 总的来说，good solution用的方法比我的高明得多，要学习！！！


## Two Sum
[link](https://leetcode.com/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
太简单了！！！ 我的第一个答案用了两个for，比较占内存，第二个答案比较省内存
答案1
```
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                if nums[i]+nums[j] == target:
                    return [i,j]
```

答案2
```
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
            j = target - nums[i]
            if j in nums and i != nums.index(j):
                return [i, nums.index(j)]
```

## Group Anagrams
[link](https://leetcode.com/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案占用太多计算资源，太蠢了！！！！
```
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        exist_type = []
        output = []
        for i in strs:
            alphabet = []
            # for j in i:
            #     alphabet.append(j)
            # alphabet.sort()
            alphabet = ''.join(sorted(i))
            if alphabet not in exist_type:
                exist_type.append(alphabet)
                output.append([i])
            else:
                index = exist_type.index(alphabet)
                output[index].append(i)
        print(output)
        return output
```

### good solution
```
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        mp = {}
        ans = []

        for s in strs:
            sorted_str = ''.join(sorted(s))
            if sorted_str in mp:
                ans[mp[sorted_str]].append(s)
            else:
                mp[sorted_str] = len(ans)
                ans.append([s])
                
        return ans
```

### 学到的东西
1. 利用 ```sorted(string)```就可以对某个string自动按照字母顺序排序, 如 sorted('eat') 会得到 ['a', 'e', 't']. 再配合使用 ```''.join() ```函数可以将原来的string按字母顺序重新组合成一个新的string, 如 ```''.join(sorted('eat'))```会得到 ```'aet'```，要记住！！！！
2. good solution利用了一个dictionary来存储每种 字母组合作为 key 并用这个组合在 ans 中的位置作为value。这样只要判断出某个string的字母组合对应于dictionary中的某个key时候，就可以直接通过 dictionary_name[key_name] 调用这个字母组合在 ans 的位置进行索引。具体见```ans[mp[sorted_str]].append(s)```. 这种方法比我用index()返回索引再调用高明多了!!!
3. 判断某个 key 是否存在于某个 dictionary 中可以直接用 ```key_name in dictionary_name```来判断，要记住！！！！
4. 另一个不在这里记录的 good solution 使用了ord()函数来返回某个字母的unicode code来进行判断，也可以记住一下这个 ```ord()``` 函数！！！


# 20241214

## Longest Consecutive Sequence
[link](https://leetcode.com/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没想到比较简单的能直接处理两组连续的数字序列并提取出其中一组的长度的方式

### good solution
```
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        nums_set = set(nums)
        res = 0
        while nums_set:
            curr = nums_set.pop()
            up, down = curr+1, curr-1
            sequence_len = 1
            
            while up in nums_set: 
                nums_set.remove(up)
                up += 1
            sequence_len += (up-curr-1)

            while down in nums_set:
                nums_set.remove(down)
                down -= 1
            sequence_len += (curr-down-1)

            res = max(res, sequence_len)
        return res
```

### 学到的东西
1. good solution的逻辑很简单，从输入序列中遍历一个数，然后判断这个数的+1或者-1对应的数字是否再输入序列中，如果存在，则表示一个连续的数字组合，然后从当前输入序列中移除这个数字，再+1或-1寻找下一个连续数字是否存在。最后总的序列长度 = 最up的一个数字-开始的数字-1(这个1是因为while循环多加/减了一个1来使得数字不存在于序列中才退出while内循环) + 开始的数字 - 最down的数字 - 1(同理)
2. good solution用了 set 配合 pop来使用，感觉的确比传统的list更加合适!!!学习!!!!!

## Subarray Sum Equals K
[link](https://leetcode.com/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没做出来，要学习good solution构建hash map存储信息的方法

### good solution
```
class Solution(object):
    def subarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        count = 0
        prefix_sum = 0
        prefix_sum_count = {0: 1}  # Initialize with prefix sum 0 and count 1
        
        for num in nums:
            prefix_sum += num  # Update the running prefix sum
            if (prefix_sum - k) in prefix_sum_count:
                count += prefix_sum_count[prefix_sum - k]  # Increment count if (prefix_sum - k) is found
            if prefix_sum in prefix_sum_count:
                prefix_sum_count[prefix_sum] += 1  # Update the frequency of the current prefix sum
            else:
                prefix_sum_count[prefix_sum] = 1  # Initialize the frequency if the prefix sum is seen for the first time
        
        return count
```

### 学到的东西
1. hash map讲白了就是一个记录  独特键出现频率的数组，根据 good solution的作者的解释，他构建了一个 hash map: ```prefix_sum_count``` 来记录所有出现的总和数字和总和数字出现的频率。出现的总和数字作为key, 频率作为 value。```prefix_sum_count```首先初始化为{0: 1}，表示一开始从0开始计算，然后此时0这个数字会在一开始就出现了，所以频率是1. 
2. 然后每遍历到一个element就计算一次总和```prefix_sum```，当```prefix_sum```减去要达到的目标值```k```可以对应到hash map中的一个键时，说明这一系列subarray已经达到了设定的目标值，那么记录subarray数量的变量```count```就加一。如我们设定目标值是 3，然后初始化是0， 那么当加到3的时候就会记录一次，从3加到6的时候又会记录一次。
3. 然后第二个if就是用于记录出现的总和数字和频率的，因为```prefix_sum```是一直往上加的，所以每出现一个新数字都会在```prefix_sum_count```中生成一个key并且频率+1，如果是出现已经存在的key，则在已经存在的key对应的value+1.
4. 总的来说就是good solution用了一个精妙的 ```prefix_sum-k```来记录每次达到设定的目标值的次数，然后将每次达到目标值后的对应的总和值保存下来，用于从当前总和值+设定的目标值达到下一个新的总和值的时候可以调用```prefix_sum-k```来判断达到了新的总和值。如初始化为0，设定的目标值为3，那么就是从 0->3->6->9. 而我老是很傻逼的一直要从0达到3，达到后再重新初始化为0，这远比good solution的想法愚蠢。下次要记住灵活一点！！！！


# 20241216

## Kth Largest Element in an Array
[link](https://leetcode.com/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的方法讲白了还是笨办法，只要数据量一大就超出时间限制
```
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        # nums.sort(reverse = True)
        length = len(nums)
        print(length)
        if length == 1:
            return nums[0]
        output = 0
        if length/2 < k and length > 1000:
            for i in range(length-k+1):
                if i != length-k:
                    min_index = nums.index(min(nums))
                    nums = nums[:min_index] + nums[min_index+1:]
                else:
                    output = min(nums)
        else:
            for i in range(k):
                if i != k-1:
                    max_index = nums.index(max(nums))
                    nums = nums[:max_index] + nums[max_index+1:]
                else:
                    output = max(nums)
                # output = nums.pop(max_index)
                print(output)
        return output
```

### good Solution
good solution用的是min_head的方法，要记住这个方法的用法
```
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        heap = nums[:k]
        heapq.heapify(heap)
        
        for num in nums[k:]:
            if num > heap[0]:
                heapq.heappop(heap)
                heapq.heappush(heap, num)
        
        return heap[0]
```

### 学到的东西
1. 看good solution的详细解释: [link](https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/3906260/100-3-approaches-video-heap-quickselect-sorting/?envType=study-plan-v2&envId=top-100-liked)
2. min head的基本思想就是先根据输入的 k 将原来的输入list提取前 k 个element(因为是前所以是head)作为一个新的数组并命名为 head。然后剩下的element每个和提取的head数组中最小的element作比较，如果有一个element大于提取的list中最小的那个element(即the top of the head)，那么将最小的那个element移除(Remove the top element from the heap), 然后将遍历到的element加入head数组。当将输入数组nums中的所有element都遍历完后， the top of the heap将会包含我们所需要的第k个大小的element.
3. heapq是python的标准库，用于处理heap queue algorithm相关的问题。相关的函数解释可以在这个链接中找到: [link](https://docs.python.org/3/library/heapq.html). 要去学！！！！！！！！！
4. heapq.heapify()是将一个list转化成head，heappop(head)是将head中最小的element pop出来并return, 同时保持head invariant。heappush(head, item)是将item push到head数组中去并保持head invariant


## Find Median from Data Stream
[link](https://leetcode.com/problems/find-median-from-data-stream/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没做出来，是看了good solution的解法后才写的代码，所以参考good Solution

### good solution
```
class MedianFinder:

    def __init__(self):
        # Min-heap for the larger half of the numbers
        self.minHeapForLargeNum = []
        # Max-heap for the smaller half of the numbers (invert numbers to use
        # heapq as a max-heap)
        self.maxHeapForSmallNum = []

    def addNum(self, num: int) -> None:
        if len(self.maxHeapForSmallNum) == 0 or -self.maxHeapForSmallNum[0] >= num:
            heapq.heappush(self.maxHeapForSmallNum, -num)
        else:
            heapq.heappush(self.minHeapForLargeNum, num)

        # Balance the heaps
        if len(self.maxHeapForSmallNum) > len(self.minHeapForLargeNum) + 1:
            heapq.heappush(
                self.minHeapForLargeNum, -heapq.heappop(self.maxHeapForSmallNum)
            )
        elif len(self.maxHeapForSmallNum) < len(self.minHeapForLargeNum):
            heapq.heappush(
                self.maxHeapForSmallNum, -heapq.heappop(self.minHeapForLargeNum)
            )

    def findMedian(self) -> float:
        if len(self.maxHeapForSmallNum) == len(self.minHeapForLargeNum):
            return (-self.maxHeapForSmallNum[0] + self.minHeapForLargeNum[0]) / 2.0
        else:
            return -self.maxHeapForSmallNum[0]


# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder()
# obj.addNum(num)
# param_2 = obj.findMedian()
```

### 学到的东西
1. good solution构造了两个head数组来实现中位数的计算，分为比中位数大的上半区数组和比中位数小的下半区数组，比中位数大的数组很简单，只要按照head的逻辑，比最小值大的就加到上半区进去，而比中位数小的数组则要取负值，因为标准库heapq的判断标准都是针对最小值，那么取负后，比中位数小的数组中最大的element就因为负号变成最小值，这样只要是比下半区最大的数字小的element都取负号然后加到下半区去。
2. 同时作者还保证上半区数组和下半区数组的element总数相差不超过1，当某个数组比另一个数组大超过这个值时，就从多的数组提取数字到少的数组中去
3. 最后当两个数组容量相同时，说明总element数是偶数，那么就把上半区的最小数字+下半区的最大数字(注意要多加负号使得element变回原来的符号)再/2. 如果数组容量不同，则说明element数是奇数，则取容量多的那个数组的head top就是中位数
4. head top方法看起来比传统方法消耗更少的计算资源，要学会使用！！！！！！


# 20241217

## Top K Frequent Elements
[link](https://leetcode.com/problems/top-k-frequent-elements/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案没想到怎么使用head数组的相关算法，占用的计算资源太多了，要学习good solution的思想!!!!!
```
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count_dict = {}
        for i in nums:
            if i not in count_dict:
                count_dict[i] = 1
            else:
                count_dict[i] = count_dict[i] + 1
                
        output = []
        for i in range(k):
            key = max(count_dict, key=count_dict.get)
            output.append(key)
            count_dict.pop(key)
        return output
```

### good solution
```
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        heap = []
        counter = {}
        for n in nums:
            counter[n] = 1 + counter.get(n, 0)
        
        for key, val in counter.items():
            heapq.heappush(heap, (-val, key))
        
        res = []
        while len(res) < k:
            res.append(heapq.heappop(heap)[1])
        
        return res
```

### 学到的东西
1. good solution采用了和我一样的dictionary来记算每个数字的出现次数，把数字作为key，把统计的数字作为value.
2. 我不知道heap数组也可以以一个set的形式加入, 如good solution中表示的那样， heapq可以允许以set的形式push信息，(value, additional_info), 集合的前面一个element对应进行比较大小的信息，后一个element则作为补充信息。举例来说，如果输入的是(2, 5) 和 (3, 4), 则因为3比2大，那么(2，5)会因为第一个element相对小的值而作为head数组的top，也就是说，如果一个head数组中同时存有(2, 5)，(3, 6)和(1, 7), 那么如果连续pop三次，依次输出会是(1, 7)，(2, 5)， (3, 6)。set中后一个element可以理解为附加给前一个element的补充信息，大小不会参与head数组中element的的排列。我之前不知道这种用法，要学习!!!!


## Add Two Numbers
[link](https://leetcode.com/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        def read_List(node,i,value):
            if node is None:
                return value
            value = value + node.val * 10**i
            value = read_List(node.next,i+1,value)

            return value
        value_l1 = read_List(l1,0,0)
        value_l2 = read_List(l2,0,0)
        value_sum = value_l1 + value_l2

        def construct_output(node,value,j):
            if value == 0:
                return node
            num = (value // 10**j) % 10
            node = ListNode(num)
            value = value - num*(10**j)
            node.next = construct_output(node.next, value,j+1)
            return node

        if value_sum == 0:
            return ListNode(0)
        else:
            node = construct_output(None, value_sum,0)
            return node
```

### good solution
```
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        
        dummy = ListNode()
        res = dummy

        total = carry = 0

        while l1 or l2 or carry:
            total = carry

            if l1:
                total += l1.val
                l1 = l1.next
            if l2:
                total += l2.val
                l2 = l2.next
            
            num = total % 10
            carry = total // 10
            dummy.next = ListNode(num)
            dummy = dummy.next
        
        return res.next
```

### 学到的东西
1. good solution没有像我那样先提取node中的数字计算为实际数字再相加再分配，而是直接做数字的相加，相当于省去了中间步骤，而不像我要搞好几个连续的函数迭代并且实际算一个百位千位的总和数字。
2. ```num = total % 10```是算余数，相当于判断l1的数字+l2的数字后得到的数字整除10以后的余数，其实l1+l2最大也就18(9+9),这个操作就是把个位数8提取出来作为当前轮次node的val, 然后用```carry = total // 10```来计算下一个分位的初始数字，例如假设当前轮次合数为18, 那么这里计算的carry就是1，那么下一轮次total的初始数字就是1而不是0. 相当于计算数字大于十则保留余数作为当前分位的数字，然后进一位+1.
3. while的判断也很巧妙，只要l1或l2不为None或carry不为0，都要执行循环一次。

## Remove Nth Node From End of List
[link](https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
仿照上一题的逻辑写的代码，我的答案就是最好的答案！！！！
```
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        depth = 0
        res = head
        while res:
            depth = depth + 1
            res = res.next
        remove_index = depth - n
        if depth == n:
            res = head.next
        else:
            i = 0

            res = head
            while i < remove_index:
                if i == remove_index - 1:
                    head.next = head.next.next
                else:
                    head = head.next
                i = i + 1
        return res
        
```
## Merge Two Sorted Lists
[link](https://leetcode.com/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我一开始使用的是```cur = list2```和```cur = list1```,导致一直报错，后面参照了good solution换成了```cur.next = list1```和```cur.next = list2```
```
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        list_sum = ListNode()
        cur = list_sum
        while list1 or list2:
            if list1 is not None and list2 is not None:
                if list1.val == list2.val:
                    cur.next = list2
                    list2 = list2.next
                    
                elif list1.val > list2.val:
                    cur.next = list2
                    list2 = list2.next
                else:
                    cur.next = list1
                    list1 = list1.next

            elif list1 is not None and list2 is None:
                cur.next = list1
                list1 = list1.next
            elif list1 is None and list2 is not None:
                cur.next = list2
                list2 = list2.next
            cur = cur.next

        return list_sum.next
```

### good solution
```
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode()
        cur = dummy

        while list1 and list2:
            if list1.val > list2.val:
                cur.next = list2
                list2 = list2.next
            else:
                cur.next = list1
                list1 = list1.next
            
            cur = cur.next
        
        if list1:
            cur.next = list1
        else:
            cur.next = list2
        
        return dummy.next
```

### 学到的东西

1. 我一开始使用的是```cur = list2```和```cur = list1```,这就会导致一个问题，当之后遍历到list1或list2中的其中一个为None时，会直接将cur变成None, 导致后面根本不会返回任何数。看了good solution的答案后改为了```cur.next = list1```和```cur.next = list2```就对了

## Merge k Sorted Lists
[link](https://leetcode.com/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没做出来

### good Solution
```
from typing import List, Optional
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        if not l1:
            return l2
        if not l2:
            return l1

        if l1.val < l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2

    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        if not lists:
            return None
        return self.divideAndConquer(lists, 0, len(lists) - 1)

    def divideAndConquer(self, lists: List[Optional[ListNode]], left: int, right: int) -> Optional[ListNode]:
        if left == right:
            return lists[left]

        mid = left + (right - left) // 2
        l1 = self.divideAndConquer(lists, left, mid)
        l2 = self.divideAndConquer(lists, mid + 1, right)
        return self.mergeTwoLists(l1, l2)
```

### 学到的东西
1. good solution的作者先将k个节点链按从两边到中间的顺序一步步地将其中的两个节点链合并，最后将k个节点链合并成最终的两个节点链，然后最终的两个节点链合并成最终的一个节点链
2. 注意看作者针对两个节点链的函数，他并不是像我们上一题那样用一个新的链，然后把两个节点链加入到新的链中，而是不断地用迭代的思想将两个节点链的值进行比较，小的那个节点链的下一个节点和大的那个节点链进入下一轮的函数循环！！！！
3. 这种涉及复杂的超过两个object的合并问题感觉还是要用函数迭代的方法完成，不能用上一题的一个while循环实现的思想。
4. 学习作者这种思路！！！！！

## Swap Nodes in Pairs
[link](https://leetcode.com/problems/swap-nodes-in-pairs/?envType=study-plan-v2&envId=top-100-liked)

### my Solution
我的答案由于没有注意simple copy时，改变copy变量也会连带改变源变量的问题，导致报错
```
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:

        i = 0
        dummy = ListNode(0,head)
        cur = head
        prev = dummy
        # print(head)
        # print(dummy)
        while cur and cur.next:
            cur_next_next = cur.next.next
            print(cur_next_next)
            cur_next = cur.next
            cur_next.next = None
            # print(cur_next)
            # print(head)
            # print(cur)
            # print(cur_next_next)
             
            cur_next.next = cur
            cur_next.next.next = cur_next_next
            prev.next = cur_next
            print(cur_next)
            # print(prev)
            # print(dummy)
            # print(head)

            prev = cur
            cur = cur_next_next
        
        return head
```

### good solution
```
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0, head)
        prev, cur = dummy, head

        while cur and cur.next:
            npn = cur.next.next
            second = cur.next

            second.next = cur
            cur.next = npn
            prev.next = second

            prev = cur
            cur = npn
        
        return dummy.next
```

### 学到的东西
1. 我的答案一开始把head使用simple copy构造了一个新变量cur，然后将cur扔到循环中进行操作。由于是simple copy，所以我们对cur做的所有操作实际上是对head进行操作。也就是说，当我们将执行 ```cur_next = cur.next``` 和 ```cur_next.next = None```后，原本```cur.next.next```之后的值就是None, 举例来说，初始head为[1,2,3,4], 我们执行```cur_next = cur.next```和```cur.next.next = None```后cur_next变为[2,None], cur变为[1,2,None], head也变为[1,2,None]. 当然此时 cur_next_next 还是 [3,4]. 当我们执行完 ```cur_next.next = cur```和```cur_next.next.next = cur_next_next```后，当然cur_next是[2,1,3,4]， 但cur和head都会是[1,3,4]， 这是因为 ```cur_next.next = cur```和```cur_next.next.next = cur_next_next```实际上会导致```cur.next = cur_next_next```，也就是说cur和head由[1,2,None]变为[1,3,4]!!!!!!
2. good solution的做法是构造一个全新的object: dummy. 以此来隔绝我们改变cur时导致的head的变化，实际上good solution的程序运行完后 head也会变成[1,3,4]， 但并不会影响到dummy, 因为循环中并没有对prev进行和cur类似的操作，而是直接将cur操作后的结果second赋值给prev了。
3. 要十分注意 simple copy带来的连带影响!!!!!!!


# 20241218
## Reverse Nodes in k-Group
[link](https://leetcode.com/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的理解是当前位置的节点和第k个位置的节点进行swap，结果是k范围内的节点都swap,不过我的思路是对的，算节点链的深度，然后判断每次循环叠加次数是否超过总深度来判断外层的while循环是否结束.

```
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        def find_kth_node(node,i,k):
            if node is None:
                return node
            if i < k:
                node = find_kth_node(node.next,i+1,k)
                return node
            elif i == k:
                return node

        def swap_node(node, follow_node, i, k):
            if node is None:
                return None
            if node.next is None:
                return node
            if i == k-1:
                node.next = follow_node
                return node
            node = swap_node(node.next, follow_node, i+1, k)
            return node
    
        dummy = ListNode(0,head)
        prev = dummy
        cur = head
        if k == 1:
            return head
        elif k >= 2:
            depth = 0
            while cur:
                cur = cur.next
                depth = depth + 1
            print(depth)
            cur = head
            i = 0
            while i + k <= depth and cur:
                cur_next_k = find_kth_node(cur.next,i+2,i+k)
                # print('cur_next_k')
                # print(cur_next_k)
                cur_next_k_next = find_kth_node(cur.next,i+1,i+k)
                # print('cur_next_k_next')
                # print(cur_next_k_next)

                if k > 2:
                    cur_mid_k = cur.next
                    cur.next = cur_next_k_next
                    # print('cur_mid_k')
                    # print(cur_mid_k)
                    # print('cur')
                    # print(cur)
                    cur_mid_k = swap_node(cur_mid_k, cur, i+2, i+k)
                    # print('cur_mid_k')
                    # print(cur_mid_k)
                    cur_next_k.next = cur_mid_k
                elif k == 2:
                    cur_next_k.next = cur
                    cur.next = cur_next_k_next
                    # print('cur_next_k')

                prev.next = cur_next_k

                # print(cur_next_k)
                # print(cur)
                # print(prev)

                prev = cur
                cur = cur_next_k_next
                
                i = i + k



            # for i in range(k):
            return dummy.next
```

### good solution
```
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        if not head or k == 1:
            return head

        dummy = ListNode(0)
        dummy.next = head
        prev = dummy
        curr = head

        # Count the number of nodes in the list
        count = 0
        while curr:
            count += 1
            curr = curr.next

        # Reverse k nodes at a time
        while count >= k:
            curr = prev.next
            nxt = curr.next

            # Reverse k nodes
            for _ in range(1, k):
                curr.next = nxt.next
                nxt.next = prev.next
                prev.next = nxt
                nxt = curr.next

            prev = curr
            count -= k

        return dummy.next
```

### 学到的东西
1. 要搞清楚python的整个 simple copy的机制，就以第二个while循环开始来说，假设例子是 head = [1,2,3,4,5], k = 3, 那么当我们赋予 ```curr = prev.next```和```nxt = curr.next```时，实际上```prev.next```和```prev.next.next```就已经会随着curr和nxt的改变而改变了(因为不是deep copy)。
2. 进入for循环的第一行代码: ```curr.next = nxt.next```，经过这一次变化后，curr变成[1,3,4,5], 而 prev也随之变成[0,1,3,4,5]。然后是第二行代码```nxt.next = prev.next```，nxt变成[2,1,3,4,5]. 然后是第三行代码: ```prev.next = nxt```， 这时候 prev变成[0,2,1,3,4,5], 最后是```nxt = curr.next```，这时nxt=[3,4,5], curr还是[1,3,4,5], prev还是[0,2，1，3，4，5].
3. 进行for循环的第二次遍历， ```curr.next = nxt.next```，这时curr=[1,4,5], prev也随着变成[0,2,1,3,4,5]. 再经过```nxt.next = prev.next```，nxt变成[3,2,1,4,5]。然后再经过```prev.next = nxt```， prev变成[0,3,2,1,4,5]，最后再经过```nxt = curr.next```， 这时候nxt变成[4,5],curr还是[1,4,5]， prev也还是[0,3,2,1,4,5]. 注意，因为prev是dummy的simple copy, 所以prev的变化实际上也是dummy的变化，所以此时dummy也是[0,3,2,1,4,5]
4. 总之整个python因为是simple copy的原因，导致整个逻辑很难理清楚，而我的代码是以为只有当前node和第k个node存在变化，所以没有用for循环一步一步地swapk范围内的每一个element.
5. 这个代码题难的地方就是理清楚整个simple copy的逻辑!!!!


## Copy List with Random Pointer
[link](https://leetcode.com/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
一开始搞不懂让我用deep copy是让我做什么

### good solution
```
class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if not head:
            return None
        old_to_new = {}
        
        curr = head
        while curr:
            old_to_new[curr] = Node(curr.val)
            curr = curr.next
        
        curr = head
        while curr:
            old_to_new[curr].next = old_to_new.get(curr.next)
            old_to_new[curr].random = old_to_new.get(curr.random)
            curr = curr.next
            
        return old_to_new[head]
```

### 学到的东西
1. 其实哈希算法就是构造一个空的新的dictionary，然后把变量名作为key,把node object作为value存进去。因为节点object自动包含了next和random, 所以后面赋值的时候也是直接赋值就好了。也就是说old_to_new[curr]调用的就是某个节点object，这个节点object里自动就包含了两个指针，一个next一个random，第二个while循环只是将原本就有的指针赋值给新构造的存在对应dictionary的value项的节点object.

# 20241219

## Linked List Cycle
[link](https://leetcode.com/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked)

### my Solution
没搞清楚NodeList的机制，没做出来

### good solution 1
```
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow_pointer = head
        fast_pointer = head
        while fast_pointer and fast_pointer.next:
            slow_pointer = slow_pointer.next
            fast_pointer = fast_pointer.next.next
            if slow_pointer == fast_pointer:
                return True
        return False
```

### good solution 2
```
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        visited_nodes = set()
        current_node = head
        while current_node:
            if current_node in visited_nodes:
                return True
            visited_nodes.add(current_node)
            current_node = current_node.next
        return False      
```

### 学到的东西
1. 我一开始没搞懂NodeList的机制，所以没做出来
2. good solution 1用的是一快一慢两个指针，慢指针每次循环进入下一个next, 快指针每次循环进入下两个next。这样如果NodeList是循环的话，总会在未来有一个时刻快指针会追上慢指针，使得两个指针指向的序列完全相同。以此来判断原NodeList是循环的
3. 第二个方法更直接了，就用hash矩阵的做法，用一个set来存储所有出现的每个节点，如果是循环的话，那么当回到那个循环点时，就会在visited_nodes中找到一模一样的object。我的问题就是只存了node的变量值而不是存整个object.

## Linked List Cycle II
[link](https://leetcode.com/problems/linked-list-cycle-ii/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
good solution提供三个思路，我的答案就是第二个思路
```
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        visited_node = set()
        curr_node = head
        while curr_node:
            if curr_node in visited_node:
                return curr_node
            visited_node.add(curr_node)
            curr_node = curr_node.next
```

### good solution 1
```
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = fast = head

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

            if slow == fast:
                break
        else: return None

        fast = head

        while fast != slow:
            fast = fast.next
            slow = slow.next
        
        return slow
```

### good solution 2
```
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        seen = set()

        def find(node):
            if not node:
                return None
            if node in seen:
                return node
            seen.add(node)
            return find(node.next)

        return find(head)
```

### 学到的东西
1. 我一开始也想用good solution 1的方法，但是忘记了有可能快指针追上慢指针的时候，双方并不一定正好位于开始循环的那个位置，而是在之后某个新的位置正好重合。所以good solution 1又加了一个新的while循环
2. good solution 2和我的答案差不多，区别只是一个是循环，一个是函数迭代


## LRU Cache
[link](https://leetcode.com/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
基本上我是没搞清楚LRU(Least Recently Used)的机制，我还以为要用一个记录器去记录使用次数和上一次使用的位置，但是答案就是只是按顺序而已。

```
class LRUCache:

    def __init__(self, capacity: int):
        self.save_dict = {}
        self.dict_len  = 2
        self.key_used = {}
        

    def get(self, key: int) -> int:
        if key in self.save_dict:
            self.key_used[key] = self.key_used[key] + 1
            return self.save_dict[key]
        else:
            return -1

        

    def put(self, key: int, value: int) -> None:
        if len(self.save_dict) < self.dict_len:
            if key in self.save_dict:
                self.save_dict[key] = value
            else:
                self.save_dict[key] = value
                self.key_used[key] = 0
        else:
            all_value = list(self.key_used.values())
            min_index = all_value.index(min(all_value))
            all_key = list(self.key_used.keys())
            min_used_key = all_key[min_index]
            del self.save_dict[min_used_key]
            del self.key_used[min_used_key]
            self.save_dict[key] = value
            self.key_used[key] = 0
```

### good solution
这个答案是基于Python 3.7以上的，根据作者的解释，Python 3.7以上的版本dictionary会自动记录插入的顺序，这样当cash数量超过设定值时，直接pop掉第一个就好了

```
class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1

        self.cache[key] = self.cache.pop(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.pop(key)

        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.pop(next(iter(self.cache)))
```

如果不是Python 3.7以上的版本，则需要调用colletion 的 OrderedDict()来实现自动记录插入顺序的功能
```
class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = collections.OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        
        self.cache.move_to_end(key)
        return self.cache[key]
        
    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(False)
```

### good solution 2
作者还构造了另外的方法，利用双端link节点来实现这个功能，但是这个系统实在太复杂了，看看就好
合成版本
```
class LinkedNode:
    def __init__(self, key = -1, val = -1):
        self.key = key
        self.val = val
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = dict()
        self.head = LinkedNode()
        self.tail = LinkedNode()
        self.head.next = self.tail
        self.tail.prev = self.head
        
    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        
        node = self.__evict(key)
        self.__addToEnd(node)
        return node.val

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            node = self.__delete(key)

        node = LinkedNode(key, value)
        self.cache[key] = node
        self.__addToEnd(node)
        
        if len(self.cache) > self.capacity:
            self.__delete(self.head.next.key)
    
    def __evict(self, key) -> LinkedNode: 
        node = self.cache[key]
        node.prev.next = node.next
        node.next.prev = node.prev
        node.next = None
        node.prev = None
        return node

    def __delete(self, key) -> None:
        deleteNode = self.__evict(key)
        del deleteNode
        del self.cache[key]

    def __addToEnd(self, node) -> None:
        node.prev = self.tail.prev
        node.next = self.tail
        self.tail.prev.next = node
        self.tail.prev = node
```
分离版本
```
class Node:
    def __init__(self, key = -1, val = -1):
        self.key = key
        self.val = val
        self.prev = None
        self.next = None

class DLL:
    def __init__(self):
        self.dummy_start = Node()
        self.dummy_end = Node()
        self.dummy_start.next = self.dummy_end
        self.dummy_end.prev = self.dummy_start

    def appendleft(self, node) -> Node:
        left, right = self.dummy_start, self.dummy_start.next
        node.next = right
        right.prev = node
        left.next = node
        node.prev = left
        
        return node

    def remove(self, node) -> Node:
        left, right = node.prev, node.next
        left.next = right
        right.prev = left
        
        return node

    def move_to_start(self, node):
        return self.appendleft(self.remove(node))

    def pop(self):
        return self.remove(self.dummy_end.prev)
    
    def peek(self):
        return self.dummy_end.prev.val

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = dict()
        self.dll = DLL()

    def get(self, key: int) -> int:
        if key not in self.cache: return -1
        
        node = self.cache[key]
        self.dll.move_to_start(node)
        
        return node.val

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            node = self.dll.remove(self.cache[key])
            node.val = value
        else:
            node = Node(key, value)
            self.cache[key] = node
        
        self.dll.appendleft(node)
        
        if len(self.cache) > self.capacity:
            self.cache.pop(self.dll.pop().key)
```

### 学到的东西
1. iter()原来就是Python里的迭代器(iterator), 功能是将一串记录多个element的array设置成迭代器模式，这样可以配合其他的函数进行遍历操作。next()函数就是和iter()配合的函数, next()函数每次都会返回迭代器中一次迭代需要返回的element, 假设一个array=[1,2,3], 那么iter(array)就好创建一个迭代器, 然后第一次next(iter(array))会返回1, 第二次(iter(array))会返回2, 第三次(iter(array))会返回3.
2. good solution中当存储的数据超过缓存时，作者的答案是直接删掉第一个,根据作者的解释，Python 3.7以上的版本的dictionary在存入数据的时候是自动排序，也就是说dictionary中存储的数据是按照存入的顺序来排列的, 基于这个原理，作者在每次get()函数中调用一次key的时候，就会通过代码```self.cache[key] = self.cache.pop(key)```重新将key-value对存储一次，这样被调用的key就会排到末尾了. 而在Python 3.7以下的版本要调用collections.OrderedDict()的话，则需要每次get的时候都执行```move_to_end(key)```将key调到dictionary的末尾。
3. good solution 2采用双端link node的方法可以参考一下，虽然的确理解起来很繁琐，但学习一下总是好的，也许未来哪天就用得上呢！！！
4. 要删除dictionary中的某个key需要用到```del dictionary_name['key']```,记住！！！！！


# 20241220

## Sort List
[link](https://leetcode.com/problems/sort-list/description/?envType=study-plan-v2&envId=top-100-liked)


### my solution
```
class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return 
        self.all_element = []
        def get_element(node):
            if node is None:
                return
            self.all_element.append(node.val)
            get_element(node.next)
            return
        get_element(head)
        self.all_element.sort()
        print(self.all_element)
        node = ListNode()
        curr = node
        for i in range(len(self.all_element)):
            curr.val = self.all_element[i]
            if i < len(self.all_element) -1:
                curr_next = ListNode()
                curr.next = curr_next
                curr = curr_next
        
        return node
```

### good solution
```
class Solution:
def sortList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        
        # Find the middle of the linked list 
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        mid = slow.next
        slow.next = None
        
        # Sort both halves
        left = self.sortList(head)
        right = self.sortList(mid)
        
        return self.merge(left, right)
    
    def merge(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
        tail = dummy
        
        while l1 and l2:
            if l1.val < l2.val:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        
        tail.next = l1 if l1 else l2
        return dummy.next
```

### 学到的东西
1. 我的答案实际上是作弊了，还是要参考good solution的思路
2. good solution实际上用的是函数backtrack的方法，将节点list不断地二等分然后排序，当函数迭代到最底层的时候就是两个node进行比较，然后返回排好序的node。然后排好序的node在上一层再进行排序。
3. 作者通过构造一快一慢两个pointer的方法来找到中间位置的node，快的指针每轮进两位，慢的指针每轮进一位。然后根据将开始到中间位置的节点链作为左半部，中间到尾部的节点链作为右半边进入下一轮函数迭代，直到最后只剩两个单独的node进行比较。或者只有一个单独的node，那就直接返回。
4. 学习他们这种sort的思路，就是不断的二分到最小进行排序，然后返回排序的队列，再在外一层再次进行排序。只要保证每次比较的时候的l1和l2都是升序的, 即l1.next一定大于l1就可以满足这个思路了.!!!!!!

## Intersection of Two Linked Lists
[link](https://leetcode.com/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        currA = headA
        currB = headB
        i = 0
        save_array = []
        while currA:
            save_array.append(currA)
            currA = currA.next
        while currB:
            if currB in save_array:
                return currB
            currB = currB.next
```

### good solution
```
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        lista = headA
        listb = headB

        while lista != listb:
            lista = lista.next if lista else headB
            listb = listb.next if listb else headA
        
        return listb
```

### 学到的东西
1. good solution的思路是将两个节点链连接起来，这样就能保证他们同时到达相交点。假设节点链A需要2个节点到达相交节点，节点链B需要3个节点到达相交节点，到达相交节点后还需要再跑4个节点，那么当我们把节点链A和B连起来，即当节点链A跑完后开始跑节点链B，节点链B跑完后开始跑节点链A，那么节点链A那一路一共要跑: 2+1(相交节点)+4+3 = 10个节点到达节点链B的相交节点, 而节点链B那一路一共要跑: 3+1+4+2 = 10个节点到达节点链A的相交节点. 所以连起来后都只需要跑相同的节点数就能到达相交节点了。
2. good solution的方法非常巧妙且只需要一共while循环，比我的好！！！！！

## Reverse Linked List
[link](https://leetcode.com/problems/reverse-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
这道题我一开始每理清楚逻辑，后面看了答案后才知道的，所以一定要回顾！！！！！
```
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return
        def create_inverse(node,inverse_node):
            if node is None:
                return node,inverse_node
            node_next = node.next
            node.next = inverse_node
            inverse_node = node
            node,inverse_node = create_inverse(node_next,inverse_node)
            return node,inverse_node
        node,inverse_node = create_inverse(head,None)

        return inverse_node
```

### good solution
```
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        node = None

        while head:
            temp = head.next
            head.next = node
            node = head
            head = temp
        
        return node
```

### 学到的东西
1. 这道题我一开始每理清楚逻辑，后面看了答案后才知道的，所以一定要回顾！！！！！
2. 其实逻辑很简单，就是按照正向遍历的逻辑，构造一个变量prev并初始化为None,表示inverse后的尾部节点值等于原节点值，而next则是None。先把当前节点的下一节点保存为一中间变量curr_next，然后用将当前节点curr的next替换成这一轮的prev，然后将当前节点curr作为下一轮循环的prev，再然后用保存的curr_next作为下一个循环的curr. 这样就可以随着节点链的不断深入不断从尾巴往回构造新节点链prev。
3. 有个小问题啊，就是以我原来认为simple copy是当我们把a simple copy成b后，重新给a指定成另外一个数会导致b也变化，但是根据这一题来看逻辑并不是这样的。a首先占据一个内存，当我们用simple copy构造了b后，b也指向这个内存，这时候如果我们指定a等于另外一个object，那么a就会指向一个新的内存，而b仍然指向原来的内存。例如 a=[1,2,3], b = a, 然后我们重新定义a = [1,4,5,6], 这时候b仍然会是[1,2,3], 但如果是 a=[1,2,3], b = a, a.append(4), 那么这时候a会变成[1,2,3,4],b也会变成[1,2,3,4]. 注意这个区别！！！！！！！！！

## Palindrome Linked List
[LINK](https://leetcode.com/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        if not head:
            return False
        save_array = []
        while head:
            save_array.append(head.val)
            head = head.next
        if save_array == save_array[::-1]:
            return True
        else:
            return False
```

### good solution
```
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        if not head or not head.next:
            return True

        # Find the middle of the list
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        # Reverse the second half of the list
        prev, curr = None, slow
        while curr:
            temp = curr.next
            curr.next = prev
            prev = curr
            curr = temp

        # Compare the two halves
        first, second = head, prev
        while second:
            if first.val != second.val:
                return False
            first = first.next
            second = second.next

        return True
```

### 学到的东西
1. good solution用的方法很巧妙，就是首先构造一慢一快两个指针来找到节点list的中间位置，然后从中间位置利用上一题的inverse方法构造一个inverse的NodeList, 因为是回文的关系，所以构造的inverse的NodeList实际上和原本的从head到中间位置的NodeList是一样的。那之后就是比较就好了。

## Rotate Image
[link](https://leetcode.com/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没做出来，注意看答案！！！

### good solution
```
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        n = len(matrix)
        # Transpose the matrix
        for i in range(n):
            for j in range(i + 1, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        # Reverse each row
        for row in matrix:
            row.reverse()
```

### 学到的东西
1. 不知道顺时针旋转90°实际上就是transpose(转置)+inverse_node
2. transpose其实就是矩阵的每个(i,j)位置的element变成(j,i),学习good solution是怎么实现的，一定要(i,j)和(j,i)同时变化，这样就不会导致遗失信息
3. 算list的inverse有函数: ```list_name.inverse()```，之前不知道, 记住！！！！！！


## Spiral Matrix
[link](https://leetcode.com/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没做出来，学习good solution的想法愚蠢

### good Solution
```
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        rows, cols = len(matrix), len(matrix[0])
        x, y, dx, dy = 0, 0, 1, 0
        res = []

        for _ in range(rows * cols):
            res.append(matrix[y][x])
            matrix[y][x] = "."

            if not 0 <= x + dx < cols or not 0 <= y + dy < rows or matrix[y+dy][x+dx] == ".":
                dx, dy = -dy, dx
            
            x += dx
            y += dy
        
        return res
```

### 学到的东西
1. 感觉像根据某种机制遍历一遍矩阵的题，可以在遍历过这个矩阵后加个标记表示这个位置已经被遍历过了以便之后重复。好多题都用了类似的思路, 要学习这个将已经访问过的位置改为某个特定符号以便之后判断的方法！！！！！
2. 好多类似遍历矩阵位置的题也用了dx，dy来根据下一时刻可能的位置是否超出矩阵的范围或者会重复到达已经遍历过的位置来进行想应的变化，要学习构造dx，dy的思想！！！！！！
3. 我一开始还没搞明白达到限定条件后dx，dy该怎么调整的机制，要注意啊！！！！！

# 20241221

## Set Matrix Zeroes
[link](https://leetcode.com/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        m = len(matrix[0])
        row_pos  = set()
        col_pos = set()
        for i in range(n):
            for j in range(m):
                if matrix[i][j] == 0:
                    row_pos.add(i)
                    col_pos.add(j)
        for i in range(n):
            for j in range(m):
                if i in row_pos or j in col_pos:
                    matrix[i][j] = 0
        
        return matrix
```

### 学到的东西
1. 基本上我的答案和大多数good solution的答案差不多，我一开始用的是list来记录zero的位置，但是这样会消耗较多的计算时间，后面改用set后发现计算时间明显降低，所以能用set就用set!!!

## Search a 2D Matrix II
[link](https://leetcode.com/problems/search-a-2d-matrix-ii/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        n = len(matrix)
        m = len(matrix[0])

        # find_target = False
        for i in range(n):
            exit_inner_loop = False
            for j in range(m):
                if matrix[i][j]==target:
                    # find_target = True
                    return True
                if matrix[i][j]>target:
                    exit_inner_loop = True
                    break
            if exit_inner_loop:
                continue  
```
### good solution
```
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        row,col=len(matrix),len(matrix[0])
        r,c=0,col-1
        while r<row and c>=0:
            if matrix[r][c]==target:
                return True
            if matrix[r][c]>target:
                c-=1
            else:
                r+=1
        return False
```


### 学到的东西
1. 这题我的答案涉及到一个当有多层循环时退出inner loop的机制, 在网上找了一个思路:
```
for ii in range(200):
    restart = False
    for jj in range(200, 400):
        ...block0...
        if something1:
            restart = True
            break
        if something2:
            exit_outer_loop = True
            break
    if restart: 
        continue #退出当前inner loop进行outer loop的下一层循环
    ...block1...
    if exit_outer_loop:
        break  #直接退出outer loop
```
通过这个方法我们可以实现当发现搜索的这一行的当前位置的值大于target时，说明这一行的后续的值都大于target, 那么我们就不需要继续搜索这一行了，直接进入下一行！！！！
2. 此外，还有一个相对容易搞混的版本，就是for+else的情况，当inner loop正常执行完结束后会执行else里的内容，但当inner loop是直接break的话，那else里的内容就不会执行，这下面else里的continue可以改为 do something，然后第二个break可以改成continue，这样就可以实现当inner loop break的时候进入outer loop的下一层循环
```
for x in range(10):
    for y in range(10):
        print(x * y)
        if x * y > 50:
            break
    else:
        continue  # only executed if the inner loop did NOT break
    break  # only executed if the inner loop DID break
```
3. good solution用的思路是一开始直接比较每一行的最后一个数，因为每一行的最后一个数是这一行的最大，如果这个数比target小，那么就不需要再考虑这一行了，直接进入下一行，如果这个数比target大，那么就往之前的列去搜索，因为每一行的后面的列的数都比前面的列的数大.
4. 记住这个退出inner loop进入下一轮outer loop的方法！！！！

## Longest Substring Without Repeating Characters
[link](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我用的是暴力破解法，需要两个for，会导致计算时间超过限制，所以主要看good solution的想法
```
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if len(s) == 0:
            return 0
        if len(s) == 1:
            return 1
        if len(s)>10000:
            return len(set(s))
        n = len(s)
        longest_length = 0
        # find_answer = False
        # for i in range(n,0,-1):
        #     for j in range(0,n-i+1):
        #         substring = s[j:j+i]
        #         unique_char = set(substring)
        #         # for k in substring:
        #         #     if k not in unique_char:
        #         #         unique_char.add(k)
        #         if len(substring) == len(unique_char):
        #             longest_length = i
        #             find_answer = True
        #             break
        #     if find_answer:
        #         break

        for window_size in range(1 if n < 10000 else 95,n+1):
            skip_step = 1 
            for j in range(0,n-window_size+1,skip_step):
                unique_char = []
                substring = s[j:j+window_size]
                unique_char = set(substring)
                if len(substring) == len(unique_char) and longest_length<window_size:
                    longest_length = window_size
                    break

        return longest_length
```

### good solution
```
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        seen = {}
        l = 0
        output = 0
        for r in range(len(s)):
            """
            If s[r] not in seen, we can keep increasing the window size by moving right pointer
            """
            if s[r] not in seen:
                output = max(output,r-l+1)
            """
            There are two cases if s[r] in seen:
            case1: s[r] is inside the current window, we need to change the window by moving left pointer to seen[s[r]] + 1.
            case2: s[r] is not inside the current window, we can keep increase the window
            """
            else:
                if seen[s[r]] < l:
                    output = max(output,r-l+1)
                else:
                    l = seen[s[r]] + 1
            seen[s[r]] = r
        return output
```

### 学到的东西
1. 作者的解释:[link](https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/347818/python3-sliding-window-o-n-with-explanation/?envType=study-plan-v2&envId=top-100-liked)
2. 作者先构造了一个dictionary来存储每个在string中出现的字母的位置，字母作为key，字母最后出现的位置作为value。同时运用了一左一右两个指针来构造window。good solution中的```l```代表left pointer的位置，```r```代表right pointer的位置, right pointer的位置随着for循环一直像右移动，每当遍历到一个字母时，就判断这个这个字母是否已经存储在```seen```这个dictionary中了, 如果不存在，说明这个字母是第一次出现，那么最大的不重复字母的string长度+1，且把这个字母+位置记录在dictionary中。如果这个字母已经存在在dictionary中，那么说明是重复出现，这时候就要看是否原先存储的同样字母的位置是否小于left pointer指向的位置，如果小于，则说明原来的字母所处的位置并不处在由left pointer 和 right pointer构成的滑动窗口中，也就是说当前滑动窗口内没有重复的字母。反之，如果原先dictionary存储的字母位置大于left pointer指向的位置，那么说明这个窗口内已经有重复的字母了(一个是原来存储的位置，一个是当前right pointer遍历到的最新位置)，这时候就要重新构造滑动窗口，保证窗口内没有重复字母，所以新的left pointer的位置要变为原来存储的位置后一位。再完成这些操作后，将最新的遍历到的字母位置更新到dictionary中。
3. good solution的方法很巧妙，只用了一个for就完成了目标。比我的好得多，要学习！！！！！

# 20241223

## Minimum Window Substring
[link](https://leetcode.com/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案虽然也想到了用左指针+右指针的方法，但是失败了，没想到怎么解决当s长度和t长度一样时怎么办
```
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        seen = {}
        l = -1
        output = ""
        min_dist = float('inf')
        n = len(s)
        char_dict = {}
        for i in t:
            if i in char_dict:
                del char_dict[i]
                char_dict[i*2] = -1
            else:
                char_dict[i]=-1
        all_char_in_s = False
        if len(s) < len(t):
            return ""

        r = 0
        max_char_length = max([len(char) for char in list(char_dict.keys())])
        print('max_char_length')
        print(max_char_length)
        while r < n:
            if s[r] in char_dict:
                if all_char_in_s is True:
                    if char_dict[s[r]] == l:
                        k = l+1
                        while k not in char_dict.values():
                            k = k + 1
                        l = k
                char_dict[s[r]] = r
                if l == -1:
                    l = char_dict[s[r]]
            if s[r-max_char_length+1:r+1] in char_dict and max_char_length > 1:
                if all_char_in_s is True:
                    if char_dict[s[r-max_char_length+1:r+1]] == l:
                        k = l+1
                        while k not in char_dict.values():
                            k = k + 1
                        l = k
                char_dict[s[r-max_char_length+1:r+1]] = r-max_char_length+1
                if l == -1:
                    l = char_dict[s[r-max_char_length+1:r+1]]
            print(l)


                
            if all_char_in_s is False and all(i >= 0 for i in list(char_dict.values())):
                all_char_in_s = True

            if r-l < min_dist and all_char_in_s is True:
                output = s[l:r+1]
                min_dist = r-l
            r = r + 1
        
        print(output)
        print(char_dict)
        print(all_char_in_s)
        return output
```

### good solution
[llink](https://leetcode.com/problems/minimum-window-substring/solutions/5485181/sliding-window-beats-100-java-python-c-js-go-rust/?envType=study-plan-v2&envId=top-100-liked)
python代码:

```
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if len(s) < len(t):
            return ""
        
        map = [0] * 128
        count = len(t)
        start = 0
        min_len = float('inf')
        min_start = 0
        
        for c in t:
            map[ord(c)] += 1
        
        for end in range(len(s)):
            if map[ord(s[end])] > 0:
                count -= 1
            map[ord(s[end])] -= 1
            
            while count == 0:
                if end - start + 1 < min_len:
                    min_start = start
                    min_len = end - start + 1
                
                map[ord(s[start])] += 1
                if map[ord(s[start])] > 0:
                    count += 1
                start += 1
        
        return "" if min_len == float('inf') else s[min_start:min_start + min_len]
```
作者把python代码换了一种逻辑来写，以下这段代码不是python语言，但是是按照作者在链接中的解释的逻辑来写的:
```
function minWindow(s, t):
    if length(s) < length(t):
        return ""
    
    # Step 1: Initialize variables
    target_freq = create empty map
    window_freq = create empty map
    
    for char in t:
        target_freq[char] += 1

    start = 0
    end = 0
    min_len = infinity
    min_start = 0
    count = 0  # Number of characters fully matched

    # Step 3: Expand the window by moving the `end` pointer
    while end < length(s):
        char_end = s[end]
        window_freq[char_end] += 1

        if char_end is in target_freq and window_freq[char_end] == target_freq[char_end]:
            count += 1

        # Step 4: When all characters are matched, try shrinking the window
        while count == number of unique characters in t:
            if (end - start + 1) < min_len:
                min_len = end - start + 1
                min_start = start

            char_start = s[start]
            window_freq[char_start] -= 1

            if char_start is in target_freq and window_freq[char_start] < target_freq[char_start]:
                count -= 1

            start += 1  # Shrink the window from the left

        end += 1  # Expand the window from the right

    if min_len == infinity:
        return ""

    return substring(s, min_start, min_start + min_len)
```
### 学到的东西
1. 总的来说good solution用的基本逻辑和我差不多，都是一左一右两个指针(作者的start指针对应我的左指针，end指针对应我的右指针)。但是作者用了两个很巧妙的方法解决了我的答案中没办法解决的问题。就是good solution通过计算每个char出现的次数来表示当一个char重复出现时所需要对应的char数，然后用一个类似dictionary来记录，char作为key, value记录在t中出现的次数。
2. 当然python版本的代码中作者用了一个```ord()```函数来将每个char都转化成唯一的数字。因为电脑中一共有128个不同类型的char，每个char都有一个唯一对应的数字编码，所以作者在python版本的代码中将读取到的每个char都转化成对应的编码作为输入的index，实际上也就是对应了key的功能。要记住这个```ord()```函数的功能！！！！！
3. 在非python语言的代码中，作者构造了两个dictionary，一个是 target_freq 对应在t中存在的char出现的次数，另一个是 window_freq 对应的是在滑动窗口中存在的char和char出现的次数。当遍历到某个char是属于 target dictionary中的key的且出现的次数=window dictionary中出现的次数(当有重复情况时，就会有出现次数大于1的情况)，就会将一个变量 count + 1, 这个变量表示 在t中出现的unique char的数量，也就是说，当滑动窗口中已经包含了所有在t中存在的char时，count就会正好 = t中存在的单独char的个数。这时候就可以开始尝试缩小滑动窗口了。
4. 在python版本的代码中，作者进行了一些简化，直接将两个dictionary都合并成一个数组 ```map```,然后将count直接初始化为t的长度。然后对t进行遍历，每当遍历到t中的一个char时，就会在map中的对应位置加1，最后的结果就是所有在t中包含的char在map数组的对应位置的value都是正数。
5. 然后在对s进行循环遍历时，每次循环到一个char，都会将这个char在map中对应位置的value-1，这会导致两个结果：因为map数组被初始化为了0，所以那些没有在t中出现的char，对应位置的值会直接变成负数。而在t中出现的char，因为一开始是正数，所以是从正数开始减的. 同样每次遍历到char时，会判断char在map数组的对应位置的值是否是正数，如果是正数，那就表示当前char属于t，那么count就会-1表示已经找到一个在t中出现的char了。当count变成0的时候，就表示所有在t中出现的char都被包含在滑动窗口中了，就开始进行滑动窗口的缩小。这就是python版本的代码和非python版本的代码在运行逻辑上的一点小差异。
6. 在作者非python版本代码的构想中，当开始尝试缩小滑动窗口时，每次循环都会比较滑动窗口和历史最小滑动窗口的长度，如果当前滑动窗口小于历史最小，那么就将当前滑动窗口的初始位置和长度分别赋予给历史最小滑动窗口的初始位置和长度。也就是说，作者构造了两个变量来存储历史最小有效滑动窗口的信息： 一是初始位置，二是窗口长度。通过这两个信息就可以返回历史最小滑动窗口对应的substring。这是我思考的时候没有想到的，要学习！！！！！
7. 在进行缩小滑动窗口的过程中，每遍历到一个char，就会将相应的```window_freq```中的位置的值-1，当遍历到的char是属于t中包含的char时且在```window_freq```中的值比在```target_freq```中的值小时，说明此时滑动窗口中包含的在t中出现的char已经少于应该出现的次数了(因为有重复char的存在，所以可能对于一个char来说，在滑动窗口中的次数为1，在target中的次数为2，这时候滑动窗口也是无效的)，这时候滑动窗口就不再有效了，那就要停止进行滑动窗口的缩小。
8. 在python版本中作者写了一个相反的逻辑，当某个char被遍历到时，在```map```数组中对应位置的值会+1，之前说过不在t中出现的char对应的值已经被减为负数，被+1后最多只能加到0. 而在t中出现的char对应位置的值一开始是正数，所以可以被加到正数。每当start指针遍历到一个在t中包含的char时，就说明当前滑动窗口已经是最后有效的位置了，这时候start指针再往右移动就会导致后面的滑动窗口不再包含这个在t中出现的char。对应到代码中就是在```map```数组中对应位置的值会变为正数，只要出现正数，就代表不能再进行start指针的移动了，所以count会+1表示下一步移动会导致有一个在t中出现的char被错过了，那就需要end指针再后续移动中再次重新找到一个这个char。所以count也变成正数导致退出内循环。
9. 总而言之，我要学习作者构造一个window dictionary和一个target dictionary的思想，还有要学习构造两个中间变量```min_start```和```min_len```来记录最小有效滑动窗口的信息以便只后来提取substring。最后就是要记住```ord()```函数的功能！！！！！

# 20241224

## Sliding Window Maximum
[link](https://leetcode.com/problems/sliding-window-maximum/description/?envType=study-plan-v2&envId=top-100-liked)

### my Solution
```
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        output = []
        l = 0
        r = 0
        window_max_index = 0
        window_max_value = float('-inf')
        if k == 1:
            return nums
        while r < n:
            if r < k-1:
                if nums[r] > window_max_value:
                    window_max_value = nums[r]
                    window_max_index = r
            if r >= k-1:
                l = r - k + 1
                if l > window_max_index:
                    window_max_value = max(nums[l:r])
                    window_max_index = nums[l:r].index(window_max_value) + l
                if nums[r] >= window_max_value:
                    window_max_value = nums[r]
                    window_max_index = r
                output.append(window_max_value)
            r = r + 1
            
        return output
```

### good solution
```
class Solution:
    def maxSlidingWindow(self, nums, k):
        result = []
        window = deque()

        for i, num in enumerate(nums):
            while window and window[0] < i - k + 1:
                window.popleft()

            while window and nums[window[-1]] < num:
                window.pop()

            window.append(i)

            if i >= k - 1:
                result.append(nums[window[0]])

        return result
```

### 学到的东西
1. 作者用了一个双端序列deque()来构造window, 通过双端序列可以实现一个功能，就是同时数组左边和右边删去element。通过第一个while循环，作者实现了当数组中的元素不属于新一轮的window的范围时，就删去。通过第二个while循环，作者实现了将数组中所有小于当前遍历到的值的element也删去。通过这两个while，作者可以保证window中的第一个element一定是当前window中最大的那个，因为如果超出范围就会被删去，小于当前值也会被删去。从而省区了我的答案中每次运行到上一轮最大的值所在位置不在window中时需要重新计算一个最大值的坐标。
2. 看来deque()这个双端序列有很大的潜力，要多学习！！！！


##  Find All Anagrams in a String
[link](https://leetcode.com/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案占用太多计算资源，不够巧妙！！！
```
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        n = len(s)
        m = len(p)
        p_dict = {}
        output = []
        sorted_p = ''.join(sorted(p))
        for i in p:
            if i not in p_dict:
                p_dict[i] = 1
            else:
                p_dict[i] = p_dict[i]+1
        last_invalid_index = -1
        invalid_window = False
        for r in range(m-1,n):
            if s[r] not in p:
                last_invalid_index = r
            if s[r] in p:
                l = r - m + 1
                if last_invalid_index >= l:
                    continue
                substring = s[l:r+1]

                if ''.join(sorted(substring)) == sorted_p:
                    output.append(l)

        
        return output
```

### good solution
```
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        # Early return if s is shorter than p
        if len(s) < len(p):
            return []

        # Initialize character counts for p and the current window in s
        p_char_count = [0] * 26  # Counts of each character in p
        window_char_count = [0] * 26  # Counts of each character in the current window of s
        result_indices = []  # List to store starting indices of anagrams

        # Populate the character count for p
        for char in p:
            p_char_count[ord(char) - ord('a')] += 1

        # Populate the initial window character count
        for i in range(len(p)):
            window_char_count[ord(s[i]) - ord('a')] += 1

        # Initialize the difference counter between p_char_count and window_char_count
        differences = 0
        for i in range(26):
            if p_char_count[i] != window_char_count[i]:
                differences += 1

        # If there are no differences, the first window is an anagram
        if differences == 0:
            result_indices.append(0)

        # Slide the window over string s
        for i in range(len(p), len(s)):
            new_char_index = ord(s[i]) - ord('a')
            old_char_index = ord(s[i - len(p)]) - ord('a')

            # Add new character to window
            window_char_count[new_char_index] += 1
            if window_char_count[new_char_index] == p_char_count[new_char_index]:
                differences -= 1
            elif window_char_count[new_char_index] - 1 == p_char_count[new_char_index]:
                differences += 1

            # Remove old character from window
            window_char_count[old_char_index] -= 1
            if window_char_count[old_char_index] == p_char_count[old_char_index]:
                differences -= 1
            elif window_char_count[old_char_index] + 1 == p_char_count[old_char_index]:
                differences += 1

            # If counts match, record the starting index
            if differences == 0:
                result_indices.append(i - len(p) + 1)

        return result_indices
```

### 学到的东西
1. good solution构造了一两个对应26个字母的list来分别存储p中字母出现的次数和滑动窗口中字母出现的次数，如果某个字母出现次数不一致，则中间变量difference+1.
2. 作者使用了ord()函数, 通过 ord(某个字母)-ord(a) 来获得每个字母的对应位置！！！
3. 作者构造了一个中间变量 difference 来判断滑动窗口的list和p数组的list的差异量，如果差异量等于0，则说明当前滑动窗口是p数组的 Anagrams.
4. 作者每遍历到一个新的字母，都会添加新遍历到的字母对应的value并且比较差异，同时减少左指针原来指向的字母对应的value并比较差异
5. 如果指针移动后的对应的滑动窗口字母list中的值和p数组list中的值相等，则差异-1，如果不相等，则考虑是否原来是相等的，变化后就不等了，如果是这种情况，则差异+1
6. 作者遍历的逻辑其实和我差不多，只是作者很巧妙地利用ord()函数构造了两个对应26字母的list来计数并比较差异，而我还是傻逼一样的sorted()后再比较。相当于我每次遍历都要重新构造一个list来比较，那肯定消耗更多的计算资源了，要学习作者的思路，一定要避免每次循环都构造一个新的list这种傻逼想法，改变老list比构造全新的list节省计算资源多了！！！！


## Valid Parentheses
[link](https://leetcode.com/problems/valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def isValid(self, s: str) -> bool:
        output = 0
        stack_array = deque()
        for i in s:
            if i is '(' or i is '[' or i is '{':
                stack_array.append(i)
                
            if i is ')':
                if len(stack_array) > 0:
                    if stack_array[-1] is '(':
                        stack_array.pop()
                    else:
                        return False
                else:
                    return False
            if i is ']':
                if len(stack_array) > 0:
                    if stack_array[-1] is '[':
                        stack_array.pop()
                    else:
                        return False
                else:
                    return False
            if i is '}':
                if len(stack_array) > 0:
                    if stack_array[-1] is '{':
                        stack_array.pop()
                    else:
                        return False
                else:
                    return False
                    
        if len(stack_array) == 0:
            return True
        else:
            return False
            

```

### good solution
```
class Solution:
    def isValid(self, s: str) -> bool:
        n = len(s)
        stack = []
        stack.append('*')
        for i in range(n):
            if s[i] in ['(', '{', '[']:
                stack.append(s[i])
            elif s[i] == ')' and stack[-1]=='(':
                stack.pop()
            elif s[i] == ']' and stack[-1]=='[':
                stack.pop()
            elif s[i] == '}' and stack[-1]=='{':
                stack.pop()
            else:
                stack.append('+')

        if stack[-1] == '*':
            return True
        return False
```


### 学到的东西
1. good solution 直接构造了一个list来判断是否属于 ```( [ {```三个中的一个，比我写三个判断句明智多了，要学习!!!
2. 作者初始化在stack中添加了一个符号，这样最后只要判断list中的最后一个element是不是这个符号就好了，比我判断长度巧妙，学习！！！！

# 20241225

## Largest Rectangle in Histogram
[link](https://leetcode.com/problems/largest-rectangle-in-histogram/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没想出来怎么解决

### good solution
```
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        maxArea = 0
        stack = []

        for index , height in enumerate(heights):
            start = index
            
            while start and stack[-1][1] > height:
                i , h = stack.pop()
                maxArea = max(maxArea , (index-i)*h)
                start = i
            stack.append((start , height))

        for index , height in stack:
            maxArea = max(maxArea , (len(heights)-index)*height)

        return maxArea  
```

### 学到的东西
1. 这题的逻辑就是，如果一个之前的bar的高度比当前遍历到的高度高，那么面积就 = 之前bar的高度 * 宽度(之前bar的index到当前bar的index). 所以每次遍历到一个bar的时候，就将这个bar存到stack数组中，当之后遍历到一个比这个bar矮的bar时，这个存入的bar就会提取出来按照之前的逻辑计算面积。所以存入stack数组的信息是(bar的index, 高度)。
2. 外循环是遍历输入的每个bar，内循环是针对stack数组中存储的bar的信息和当前遍历到的bar的信息进行比较，如果存储的bar的高度比当前bar的高度高，则提取出来。当内循环while有两个退出机制，第一是遍历到第一个element，即start = 0的时候，就退出内循环。第二是存储的bar的高度比当前bar的高度高
3. 结束所以的循环后，将stack数组中剩余的bar再遍历一次，计算剩下的bar能够构成的最大面积和之前计算的最大面积哪个大。因为stack中剩下的bar都是比它之后遍历到的bar高度小的bar，所以可以一直到尾部都是连续的面积，比如说例子中的第二个bar，它的高度是1，它可以一直连续到最后形成一个较大的面积。因为可能出现的时间早，所以宽度会高，所以用```len(heights)-index```来计算宽度，再乘以剩下的bar的高度得到面积。
4. 学习这个算法的逻辑！！！！

## Min Stack
[link](https://leetcode.com/problems/min-stack/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_val = float("inf")

        

    def push(self, val: int) -> None:
        self.stack.append(val)
        if val < self.min_val:
            self.min_val = val
        

    def pop(self) -> None:
        pop_val = self.stack.pop()
        if len(self.stack) > 0:
            if self.min_val == pop_val:
                self.min_val = min(self.stack)
        elif len(self.stack) == 0:
            self.min_val = float("inf")
        return pop_val
        

    def top(self) -> int:
        return self.stack[-1]
        

    def getMin(self) -> int:
        return self.min_val
```

### good solution

```
class MinStack:

    def __init__(self):
        self.stack = []
        self.minStack = []
        

    def push(self, val: int) -> None:
        self.stack.append(val)
        val = min(val , self.minStack[-1] if self.minStack else val)
        self.minStack.append(val)
        

    def pop(self) -> None:
        self.stack.pop()
        self.minStack.pop()
        

    def top(self) -> int:
        return self.stack[-1]
        

    def getMin(self) -> int:
        return self.minStack[-1]
```

### 学到的东西
1. good solution构造了一个minStack来存储每次push一个val给stack时候的stack的最小值，minStack和stack的长度是一样的，也就是说stack中每一个element都可以在minstack中找到与它同index的当这个element被加入到stack时刻的最小值。当pop()一个stack中的element时，同时也要pop()一个minstack的最小值保证两者长度一致。调用getMin()函数时只需要返回minStack中的最后一位就好了，因为minStack每个位置的元素的值都代表当Stack长度为这个index的时候Stack中的最小值。
2. 要学习这个构造minStack的思路！！！

## Decode String
[link](https://leetcode.com/problems/decode-string/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没做出来，想的不够全面，注意good solution的答案

### good solution
```
class Solution:
    def decodeString(self, s: str) -> str:
        stack = []
        current_string = ""
        num = 0

        for char in s:
            if char.isdigit():
                # Build the number for repeat count
                num = num * 10 + int(char)
            elif char == "[":
                # Push the current context to stack
                stack.append((current_string, num))
                current_string = ""
                num = 0
            elif char == "]":
                # Pop and combine the repeated substring
                last_string, repeat_count = stack.pop()
                current_string = last_string + current_string * repeat_count
            else:
                # Append character to the current string
                current_string += char

        return current_string
```

### 学到的东西
1. string.isnumeric()和string.isdigit()可以用来判断一个string是不是数字。string.isalpha()可以用来判断一个string是不是字母串。
2. 我的答案是先将各段string存储起来，最后再合并，结果出问题了。就应该像good solution这样直接在遍历的过程中不断构造string并且存储在stack中
3. 作者为了解决括号内还有括号的问题，每次出现 ```[```时都会将当前的```current_string```添加到stack中，在出现```]```后再将stack中存储的string提取出来
4. 作者用了很巧妙的方法计算次数: ```num = num * 10 + int(char)```，直接就可以计算数字，而不需要像我一样用一个array将string形式的数字存储起来再叠加再转换为数字。要学习这个思路！！！！
5. 如果遍历到的element是字母，那么直接相加就可以构造string了: ```current_string+= char```。我又是同样用一个array分别存储再用```''join(string_list)```来合并成一个string，简直傻逼！！！
6. 反正要学习这个stack的思路！！！！！

## Daily Temperatures
[link](https://leetcode.com/problems/daily-temperatures/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution:
我的答案用了很多没必要的繁琐的代码，导致计算时间爆炸，多学习good solution的思路
```
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        stack = []
        output = [0]*n
        stack.append((0,temperatures[0]))
        for i in range(1,n):
            if temperatures[i] <= stack[-1][1]:
                stack.append((i,temperatures[i]))
            if temperatures[i] > stack[-1][1]:
                while len(stack)>0:
                    if temperatures[i] <= stack[-1][1]:
                        break
                    index, _ = stack.pop()
                    index_dist = i - index
                    output[index]= index_dist

                stack.append((i,temperatures[i]))

        return output
```

### good solution:
```
class Solution:
    def dailyTemperatures(self, temps):
        results = [0] * len(temps)
        stack = []
        # UPVOTE !
        for i, temp in enumerate(temps):
            while stack and temps[stack[-1]] < temp:
                index = stack.pop()
                results[index] = i - index
            stack.append(i)

        return results
```

### 学到的东西
1. 同时遍历index 和element的值可以用 enumerate()函数: ```for index, value in enumerate(list)```,不用像我老是只能 ```for i in range(len(list))```。要学习！！！！
2. 我写代码的时候出现了当stack数组为空的时候while循环的比较大小会报错，我是用了很傻逼的办法来解决的。good solution的办法就是直接先判断 ```while stack```， 当stack数组为空的时候就直接退出while了从而不会影响后面的条件判断！！！ 通过这个就可以删去我的答案中那两个if条件句了其实！！！

# 20241226
[link](https://leetcode.com/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def maxArea(self, height: List[int]) -> int:
        n = len(height)
        left = 0
        right = n-1
        max_area = 0
        while left != right:
            curr_height = min(height[left],height[right])
            curr_weight = right-left
            curr_area = curr_height*curr_weight
            max_area = max(max_area, curr_area)
            if height[left] >= height[right]:
                right = right -1
            else:
                left = left + 1
        
        return max_area
```

### good solution
```
class Solution:
    def maxArea(self, height: List[int]) -> int:
        max_area = 0
        left = 0
        right = len(height) - 1

        while left < right:
            max_area = max(max_area, (right - left) * min(height[left], height[right]))

            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        
        return max_area
```

### 学到的东西
1. 我是在good solution的提示下才写出来的，所以参考good solution的逻辑
2. 两点法讲白了就是不断比较两点之间的信息，然后再通过两点之间的信息对某一个点做出一定的改变，然后继续比较
3. 这里是设定一左一右两个点，然后左指针从0开始，右指针从最后一位开始，两点高度比较，高度小的那个乘以两点间距(宽度)得面积。然后两个点高度小的那个点移动一位，再次比较，直到两点重合。

# 3Sum
[link](https://leetcode.com/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked)

### good solution
```
def threeSum(self, nums: List[int]) -> List[List[int]]:

	res = set()

	#1. Split nums into three lists: negative numbers, positive numbers, and zeros
	n, p, z = [], [], []
	for num in nums:
		if num > 0:
			p.append(num)
		elif num < 0: 
			n.append(num)
		else:
			z.append(num)

	#2. Create a separate set for negatives and positives for O(1) look-up times
	N, P = set(n), set(p)

	#3. If there is at least 1 zero in the list, add all cases where -num exists in N and num exists in P
	#   i.e. (-3, 0, 3) = 0
	if z:
		for num in P:
			if -1*num in N:
				res.add((-1*num, 0, num))

	#3. If there are at least 3 zeros in the list then also include (0, 0, 0) = 0
	if len(z) >= 3:
		res.add((0,0,0))

	#4. For all pairs of negative numbers (-3, -1), check to see if their complement (4)
	#   exists in the positive number set
	for i in range(len(n)):
		for j in range(i+1,len(n)):
			target = -1*(n[i]+n[j])
			if target in P:
				res.add(tuple(sorted([n[i],n[j],target])))

	#5. For all pairs of positive numbers (1, 1), check to see if their complement (-2)
	#   exists in the negative number set
	for i in range(len(p)):
		for j in range(i+1,len(p)):
			target = -1*(p[i]+p[j])
			if target in N:
				res.add(tuple(sorted([p[i],p[j],target])))

	return res
```

这是对good solution的优化版本

```
from collections import defaultdict

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        neg = defaultdict(int)
        pos = defaultdict(int)
        zeros = 0
        
        for x in nums:
            if x < 0:
                neg[x] += 1
            elif x > 0:
                pos[x] += 1
            else:
                zeros += 1
        
        r = []
        
        if zeros:
            for n in neg:
                if -n in pos:
                    r.append((0, n, -n))
        
            if zeros > 2:
                r.append((0,0,0))

        for set_a, set_b in ((neg, pos), (pos, neg)):
            set_a_items = list(set_a.items())
            for i, (x, q) in enumerate(set_a_items):
                for x2, q2 in set_a_items[i:]:
                    if x != x2 or (x == x2 and q > 1):
                        if -x-x2 in set_b:
                            r.append((x, x2, -x-x2))

        return r
```

### 学到的东西
1. good solution的作者首先将数组分为三个子数组，分别包含正数，负数和0.
2. 然后分成三种情况：1.包含一个0，这时候需要从正数数组和负数数组中分别提取一个绝对值相等的相反数对构成和为0. 2. 存在三个0，则直接构成和为0。3. 存在一负两正或一正两负，则从正数数组或者负数数组中遍历出两个值，然后计算和，再判断这个和能不能在另外一个数组中找到对应相反数，如果找得到，则条件符合。
3. 改良版本直接计算输入的零的数量，而不是构造一个包含所有0的数组
4. 同时改良版本通过```for set_a, set_b in ((neg, pos), (pos, neg))```的方式实现先从负数数组中寻找两个数字，然后算和再在正数数组中寻找这个和的相反数。然后第二次循环遍历从正数数组中寻找两个数，再从负数数组中计算和的相反数。而不用像原来的good solution那样写两个if条件句。这种写法很高级，要学习！！！！


## Trapping Rain Water
[link](https://leetcode.com/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案是看了good solution的逻辑写出来的，基本还是看good solution的解释
```
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        left = 0
        right = n-1
        left_max = 0
        right_max = 0
        water = 0
        while left != right:
            if height[left] > left_max:
                left_max = height[left]
            if height[right] > right_max:
                right_max = height[right]
            if right_max <= left_max:
                water = water + right_max - height[right]
                right = right - 1
            else:
                water = water + left_max - height[left]
                left = left + 1

        return water
```

### good Solution
[作者解释](https://leetcode.com/problems/trapping-rain-water/solutions/5126477/video-keep-max-height-on-the-both-side/?envType=study-plan-v2&envId=top-100-liked)
```
class Solution:
    def trap(self, height: List[int]) -> int:
        left = 0
        right = len(height) - 1
        left_max = height[left]
        right_max = height[right]
        water = 0

        while left < right:
            if left_max < right_max:
                left += 1
                left_max = max(left_max, height[left])
                water += left_max - height[left]
            else:
                right -= 1
                right_max = max(right_max, height[right])
                water += right_max - height[right]
        
        return water
```

### 学到的东西
1. 基本上也是两点法，从最开始和最后的位置开始算，然后比较两个点的最大高度，选择最大高度相对较小的那个位置开始移动，如果某一边的最大高度小于移动到的新点，则把最大高度更新。每当某一边移动到的新点小于最大高度时，就用这一边的最大高度减去移动到的新点的高度获得这个位置运行的water储存量，然后将这个计算的water储存量加上原来的water量。
2. 具体详细解释可以看[作者的解释](https://leetcode.com/problems/trapping-rain-water/solutions/5126477/video-keep-max-height-on-the-both-side/?envType=study-plan-v2&envId=top-100-liked)

# 20241227

## Move Zeroes
[link](https://leetcode.com/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我一开始的代码没有用两点法做，用的pop()配合append()来做的
```
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)

        index = 0

        while index < n:
            if nums[index] == 0:
                nums.pop(index)
                nums.append(0)
                n = n - 1
            else:
                index = index + 1
```
后面看了good solution的逻辑写了自己的代码
```
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)

        left = 0
        right = 0
        while right < n:
            if right == left:
                right = right + 1
                continue
            if nums[left] == 0 and nums[right] !=0:
                nums[left] = nums[right]
                nums[right] = 0
                left = left + 1
            if nums[right] == 0:
                right = right + 1
            if nums[left] != 0:
                left = left + 1

```

### good solution
```
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        left = 0

        for right in range(len(nums)):
            if nums[right] != 0:
                nums[right], nums[left] = nums[left], nums[right]
                left += 1
        
        return nums
```

### 学到的东西
1. 感觉如果按照good solution的逻辑，如果第一位不是零，那么left都会直接加1，right则会按照for循环的逻辑往后遍历。反正只要保证零在后边就行了，前面的正数是否还按照原来的顺序并不重要。只要不断地将right遍历到的非零项移动到list的零项的左侧就好了，right指针一定是快于或等于left指针的，因为当right遍历到0项的时候并不会触发交换和left指针进一位。
2. [作者解释](https://leetcode.com/problems/move-zeroes/solutions/5246963/video-two-pointer-solution/?envType=study-plan-v2&envId=top-100-liked)

## Implement Trie (Prefix Tree)
[link](https://leetcode.com/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案占用的计算资源相对较多，还是参考good solution的思想
```
class Trie:

    def __init__(self):
        self.dict = {}
        

    def insert(self, word: str) -> None:
        self.dict[word] = 0
        

    def search(self, word: str) -> bool:
        return word in self.dict
        

    def startsWith(self, prefix: str) -> bool:
        for i in self.dict.keys():
            if prefix == i[0:len(prefix)]:
                return True

        return False
```

### good solution 
```
class Trie:

    def __init__(self):
        self.root={}
        
    def insert(self, word: str) -> None:

        cur=self.root

        for letter in word:
            if letter not in cur:
                cur[letter]={}
            cur=cur[letter]

        cur['*']=''

    def search(self, word: str) -> bool:

        cur=self.root
        for letter in word:
            if letter not in cur:
                return False
            cur=cur[letter]

        return '*' in cur
        
    def startsWith(self, prefix: str) -> bool:

        cur=self.root
        for letter in prefix:
            if letter not in cur:
                return False
            cur=cur[letter]

        return True
```

### 学到的东西
1. good solution的想法相当于是将word的每个字母都作为一个key, 同时value初始化为一个dictionary并存储下一个遍历到的字母，也就是说构造了一个嵌套的结构来存储输入的word。
2. 这样做的好处就是在进行search和startsWith时可以很清晰地遍历每个字母。

## Next Permutation
[link](https://leetcode.com/problems/next-permutation/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没做出来，没想到做题的逻辑是什么，学习good solution的解题逻辑

### good solution
```
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        n = len(nums)
        i = n - 2
        
        # Step 1: Find the breakpoint
        while i >= 0 and nums[i] >= nums[i + 1]:
            i -= 1
        
        if i >= 0:
            # Step 2: Find the smallest element larger than nums[i]
            j = n - 1
            while nums[j] <= nums[i]:
                j -= 1
            # Swap nums[i] and nums[j]
            nums[i], nums[j] = nums[j], nums[i]
        
        # Step 3: Reverse the subarray to the right of i
        nums[i + 1:] = reversed(nums[i + 1:])
```

### 学到的东西
1. good solution的[作者解释](https://leetcode.com/problems/next-permutation/?envType=study-plan-v2&envId=top-100-liked)
2. 我没想到解决这个题目的思路，其实就是从右往左寻找第一个降序位置。比如[1,2,4,3],则我们要找到的第一个降序位置的对应值就是2，因为2比4小。这个降序位置的值可以被视为一个breakpoint。如果找不到降序位置的值，则说明整个数列从右往左是完全升序排列，这样就说明整个序列已经是最大的排列等级了，例如[4,3,2,1],那么下一步就直接反转成[1,2,3,4]
3. 然后从右到这个breakpoint的位置，寻找一个比这个breakpoint位置的值大的最小值，将这个比breakpoint位置的值大的最小值和这个breakpoint位置的值进行替换。完成替换操作后，将breakpoint位置右边的子array进行reverse操作。如[1,2,4,3]替换成[1,3,4,2],然后子序列[4,2]再反转成[2,4]最后形成[1,3,2,4].
4. 反转操作python中有专门针对的函数名为reversed()!!!!记住！！！！！

# 20241228
## First Missing Positive
[link](https://leetcode.com/problems/first-missing-positive/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的解法实际上不符合题目要求，占用的计算时间超过要求的时间限制，要学习good solution的解法
```
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        nums = [n for n in nums if n > 0]
        nums.sort()
        min_pos = 1
        i = 0
        while i < len(nums):
            if min_pos in nums:
                min_pos = min_pos + 1
            else:
                return min_pos
            i = i + 1
        return min_pos
```

### good solution
```
class Solution:
    def firstMissingPositive(self, nums):
        n = len(nums)
        
        # Step 1: Place numbers in their correct positions
        for i in range(n):
            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
        
        # Step 2: Identify the first missing positive
        for i in range(n):
            if nums[i] != i + 1:
                return i + 1
        
        return n + 1
```

### 学到的东西
1. 这个题目的目的是找出未写出来的最小正整数，对于一个长度为n的数组来说，如果这个数组全部是升序排列且都是正整数且中间每缺少任何正数的话，则最多可以构成一个从1开始记录，最终值为n的数组。也就是说，实际上可以去遍历输入数组的每个element，如果这个element的值 n 满足0到n这个范围的话，可以把这个数 n 放到 n-1 那个位置去。例如index=1的位置应该是2，index=3的位置应该是4.这样将数组重新整理一遍之后，再次遍历这个数组，只要出现这个位置的element的值不是位置index+1，就说明这个index+1的值不包含在输入数组中。
2. good solution的想法就是遍历数组中的每个值，只要某个值 i 符合 大于0 小于等于n, 且不位于 i-1 这个位置上的话，就将这个值换到 i-1 这个位置上去。
3. 最后再次遍历的时候就只要出现某个位置的值不等于这个位置的index+1，就可以说明 index +1 这个值是缺少的

## Maximum Subarray
[link](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我用的是动态数组的方法
```
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        dynamic_array = [float('-inf')] * n
        dynamic_array[0] = nums[0]
        for i in range(1,n):
            dynamic_array[i] = max(nums[i], nums[i] + dynamic_array[i-1])

        return max(dynamic_array)
```

### good solution
```
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:            
        res = nums[0]
        total = 0

        for n in nums:
            if total < 0:
                total = 0

            total += n
            res = max(res, total)
        
        return res
```

### 学到的东西
1. 我用的是动态数组的方法，记录每个位置的element能够获得的最大值，通过当前位置和前一个位置能够获得的最大值进行比较
2. good solution更直接，直接构造一个total变量来记录之前的总和，且当total变为负的时候，就重新设定为0，这样当total加上当前位置的值的时候就变成当前位置的值了。

## Merge Intervals
[link](https://leetcode.com/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x: x[0])
        print(intervals)
        n = len(intervals)
        if n <= 1:
            return intervals
        output = []
        for i in range(n):
            if i == 0:
                last_array = intervals[i]
            else:
                print(last_array)

                if last_array[1] >= intervals[i][0]:
                    last_array = [min(last_array[0],intervals[i][0]), max(last_array[1],intervals[i][1])]

                else:
                    output.append(last_array)
                    last_array = intervals[i]
                if i == n-1:
                    output.append(last_array)
        return output
                
```

### good solution
```
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x: x[0]) # Sort intervals by start time
        k = 0 # Index for merged intervals
        
        for i in range(1, len(intervals)):
            if intervals[k][1] >= intervals[i][0]: # Overlap detected
                intervals[k][1] = max(intervals[k][1], intervals[i][1]) # Merge
            else:
                k += 1 # Move to the next position
                intervals[k] = intervals[i] # Replace in-place
        
        return intervals[:k + 1] # Return only merged intervals
```

### 学到的东西
1. good solution直接修改原来的输入数组，最后再返回所有已经调整过后的数组，而不是像我那样专门构造一个中间数组然后进行操作。

## Sort Colors
[link](https://leetcode.com/problems/sort-colors/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我感觉我的答案逻辑上是有问题的，当遍历到某个点为0的时候，我的想法是将这个点pop出来，然后再将这个点插到开头去。在这个pop()操作和insert()操作的过程中，nums的长度应该是先减小一位再回复成原来的长度。那么这时候按理来说index要增加一位以便遍历到下一个index，但是当我在第一个if条件句中使用 i=i+1 反而会报错index out of length， 而维持i 不变反而没报错，我觉得有点奇怪！！！！ 还是看good solution的解法吧。
```
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        i = 0
        j = 0
        while i < n and j < n:

            if nums[i]==0 and i > 0:
                val = nums.pop(i)
                nums.insert(0,val)
                i = i 
                print(nums)
                
            if nums[i]==2:
                val = nums.pop(i)
                nums.insert(n-1,val)
                print(nums)
            else:
                i = i + 1
            j = j + 1

```

### good Solution
```
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        low, current, high = 0, 0, len(nums) - 1

        while current <= high:
            if nums[current] == 0:
                nums[low], nums[current] = nums[current], nums[low]
                low += 1
                current += 1
            elif nums[current] == 1:
                current += 1
            else:
                nums[current], nums[high] = nums[high], nums[current]
                high -= 1
```

### 学到的东西
1. good solution的想法简单来说就是构造三个指针: low, high, current.
2. 当current指向element的值为0时，将current指针和low指针对应的值互换，然后low指针和current指针都+1
3. 当current指向的值为1时，单纯current指针+1
4. 当current指向2时，将current指针和high指针指向的值互换，然后high-1
5. 通过这样可以保证current指针一定>=low指针，同时current指针一定<=high指针，当current指针大于high指针的时候，循环结束
6. 总的来说Misc法看上去就是不断进行array内元素的值的交换！！！

## Single Number
[link](https://leetcode.com/problems/single-number/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        hash_dict = {}
        for i in nums:
            if i not in hash_dict:
                hash_dict[i] = 1
            else:
                hash_dict[i] = 2

        index = list(hash_dict.values()).index(1)
        key = list(hash_dict.keys())[index]
        return key
```

### good solution
```
class Solution {
    public int singleNumber(int[] nums) {
        // Initialize the unique number...
        int uniqNum = 0;
        // TRaverse all elements through the loop...
        for (int idx : nums) {
            // Concept of XOR...
            uniqNum ^= idx;
        } return uniqNum;       // Return the unique number...
    }
}
```

### 学到的东西
1. ```^```符合对应Xor操作，当两个相同的数进行Xor时，会得到0，而零和任何数进行Xor都会得到这个数，也就是说如果数组中只有一个值会出现一次，其他的都会出现两次，那直接将所有值全部进行Xor操作，最后得到的结果就是那个单独的值。

## Majority Element
[link](https://leetcode.com/problems/majority-element/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        hash_dict = {}
        for i in nums:
            if i not in hash_dict:
                hash_dict[i] = 1
            else:
                hash_dict[i] = hash_dict[i] + 1
        

        max_index = list(hash_dict.values()).index(max(list(hash_dict.values())))
        return list(hash_dict.keys())[max_index]
```

### good solution
```
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        return nums[n//2]
```

### 学到的东西
1. 没什么好说的， good solution直接返回超过总数一半的element


## Rotate Array
[link](https://leetcode.com/problems/rotate-array/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        for i in range(k):
            val = nums.pop()
            nums.insert(0,val)
        return nums
```

### good solution
```
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        n = len(nums)
        k %= n
        nums.reverse()
        nums[:k] = reversed(nums[:k])
        nums[k:] = reversed(nums[k:])
```

### 学到的东西
1. 作者直接用三个连续的reverse函数完成工作，先计算k和输入数组长度的余数，因为如果k大于n，则k实际上只需要旋转k除以n的余数次就可以了
2. 作者第一次将整个array Reverse、
3. 然后将前k个逆转
4. 然后将k之后的elemen也逆转
5. 通过这样就实现了旋转k次，比我的先pop再insert精妙多了，学习!!!!!

## Product of Array Except Self
[link](https://leetcode.com/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没想到符合计算度O(n)切不用除法的方法

### good Solution
```
def productExceptSelf(nums):
    n = len(nums)
    result = [1] * n

    # First pass: Calculate prefix products
    for i in range(1, n):
        result[i] = result[i - 1] * nums[i - 1]

    # Second pass: Calculate suffix products on the fly
    suffix = 1
    for i in range(n - 1, -1, -1):
        result[i] *= suffix
        suffix *= nums[i]

    return result
```

### 学到的东西
1. good solution先正向循环算了一个连乘，将每个位置存储对应位置连乘的结果。再反向循环算一个连乘，将反向连乘结果和正向连乘结果乘起来就是除了每个位置的值之外的值乘起来的结果。

## Find the Duplicate Number
[link](https://leetcode.com/problems/find-the-duplicate-number/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        array = {}
        for i in nums:
            if i not in array:
                array[i]=0
            else:
                return i
```

### good solution
```
        slow = nums[0]
        fast = nums[0]

        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break

        slow = nums[0]
        while slow != fast:
            slow = nums[slow]
            fast = nums[fast]
            
        return slow
```

### 学到的东西
1. 快慢指针用的是Floyd's cycle detection algorithm，即设置一个快指针和一个慢指针，让快指针的行进速率是慢指针的两倍。因为输入数组存在重复项，所以会出现两个index的值都指向同一个值 val，这时候只要使用nums[val]就会开始下一个循环。
2. 通过Floyd's cycle detection algorithm算法，快指针比慢指针多走一倍的路程，假设从起点到循环起点的路程为m，从循环起始点到相遇点走的路程为k，循环的总长度为n。那么当快慢指针相遇时，两者走的路程为 (m + n*x + k) 和 (m + n*y + k), 其中x和y分别是快慢指针循环的次数。 因为两者相遇，所以两式是相等的，即 (m + n*x + k) = 2*(m + n*y + k), 这样就可以得出 m + k = (x – 2y)*n, 也就是说 m+k是n的整数倍。
3. 上式可以写成 m = (x – 2y)*n - k, 然后再写成 m = (x – 2y-1)*n + n - k, (x-2y-1)实际上可以看成是另外一个整数z，也就是说有 m = z*n + n - k, 也就是说，从起点到循环起点的距离等于快慢指针的相遇点走完剩下的循环内的路程再加上循环的整数倍。那么这时候我们将慢指针重新定位到初始位置，然后让二者以相同的速率行动，他们再次相遇的点就是循环的起点。
4. 具体可以看这个[视频](https://www.youtube.com/watch?v=PvrxZaH_eZ4)
5. 通过这个方法，将相遇的点的值返回就是那个重复的值！！！