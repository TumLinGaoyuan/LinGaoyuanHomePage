# 20241112
## Letter Combinations of a Phone Number
[题目链接](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```angular2html
class Solution(object):
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        phone = {"1": [], "2": ['a','b','c'], "3": ['d','e','f'], "4": ['g','h','i'], "5":['j','k','l'], "6":['m','n','o'], "7":['p','q','r','s'],"8":['t','u','v'],"9":['w','x','y','z']}
        
        length_digits = len(digits)
        if length_digits == 0:
            output = []
        elif length_digits == 1:
            output = phone[digits]
        elif length_digits > 1:
            digits_split = list(digits)
            output = []
            if length_digits == 2:
                for i in phone[digits_split[0]]:
                    for j in phone[digits_split[1]]:
                        element = i+j
                        output.append(element)
            elif length_digits == 3:
                for i in phone[digits_split[0]]:
                    for j in phone[digits_split[1]]:
                        for k in phone[digits_split[2]]:
                            element = i+j+k
                            output.append(element)
            elif length_digits == 4:
                for i in phone[digits_split[0]]:
                    for j in phone[digits_split[1]]:
                        for k in phone[digits_split[2]]:
                            for l in phone[digits_split[3]]:
                                element = i+j+k+l
                                output.append(element)
        return output

```

### good solution`
```angular2html
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        
        digit_to_letters = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz',
        }

        def backtrack(idx, comb):
            if idx == len(digits):
                res.append(comb[:])
                return
            
            for letter in digit_to_letters[digits[idx]]:
                backtrack(idx + 1, comb + letter)

        res = []
        backtrack(0, "")

        return res

```
### 学习到的点
1. string可以直接for loop, 如
   ```
   for i in '23':
        print(i)
   ```
   会直接返回'2'和'3', 并不需要先转化为list再for loop
2. 想要把两个string组合到一起直接相加就好， 如 a = 'lala', b='haha', 则 a+b = 'lalahaha'.
3. 我原本不知道怎么根据输入的digits的长度创建对应数量的for循环, 如digits='234', 则长度为3，那就需要3个for循环来构造字母组合, 一如我自己的solution这样。但good solution中通过构造一个函数并在函数内嵌套for循环的方法来实现这个功能，同时设定当idx达到digits的长度时则退出。基本逻辑如下：假设我们的输入 digits = '23'. 最外层调用为 backtrack(0,""), 这时候 idx=0，comb为空。然后if判断显然不成立。接着进入第一个循环, 这时候 for 循环数字 2 对应的所有字母，第一个为 'a', 然后再次调用函数 backtrack(idx + 1, comb + letter), 进入第一个函数嵌套，此时嵌套函数输入实际值为 backtrack(1,'a') . 再次判断if条件，明显 idx == 1 而 len(digits) == 2, 所有if条件不满足，不会加入到最终的返回数组 res 里， 这时候进行嵌套的第二个 for 循环， 这时候 for 循环数字 3 对应的所有字母， 第一个为 'd', 然后再次调用函数 backtrack(idx + 1, comb + letter) 进入第三层嵌套函数，这时函数的输入实际值是 backtrack(2, 'ad'). 进入第三层函数嵌套后，再次进行if判断, 此时满足if条件，则将 'ad' 加入到最终的返回数组 res 里，然后退出第三层函数嵌套，回到第二层函数嵌套。在第二层函数嵌套中，for循环的第二个字母是 'e'， 则重新调用 backtrack(idx + 1, comb + letter) 进入一个新的第三层函数嵌套，此时函数输入是 backtrack(2,'ae'), 同样满足if条件，所有 'ae' 也加入到 res中. 以此类推，当第二层函数嵌套的for循环结束后，自动返回到第一层函数嵌套的 for 循环的下一次 iteration， 数字2 对应的第二个字母是 'b’ 然后调用 backtrack(idx + 1, comb + letter) 重新进入新的第二层函数嵌套， 这时函数输入是 backtrack(1, 'b')， 同理在这个第二层函数嵌套中同样进行三次针对数字 3 对应字母的 循环迭代， 将 'bd', 'be', 'bf' 加入到 res中, 然后又再次回到第一层函数嵌套进行第三轮 'c' 的函数嵌套。通过这种函数和for循环互相嵌套，并且在函数内再次调用函数的方式实现了我不知道怎么解决的问题。


# 20241113

## Generate Parentheses(未做对)
[题目链接](https://leetcode.com/problems/generate-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案是不完整的，当n=4时候，我只能返回12个结果，而正确答案应该返回14个结果
```
class Solution(object):
    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """

        output = []
        def backtrack(n, parenthese_pairs):
            count = n
            while count > 0:
                left_parenthese_element = '('*count
                if count == n:
                    parenthese_pairs_new = parenthese_pairs + left_parenthese_element + n*')'
                    output.append(parenthese_pairs_new)
                    count = count - 1
                else:
                    for i in range(1, count+1):
                        right_parenthese_element = i*')'
                        if len(left_parenthese_element) == len(right_parenthese_element):
                            parenthese_pairs_new = parenthese_pairs + left_parenthese_element + right_parenthese_element
                            backtrack(n-i, parenthese_pairs_new)
                            break
                        parenthese_pairs_new = parenthese_pairs + left_parenthese_element + right_parenthese_element + (n-count)*'(' + (n-i)*')'
                        output.append(parenthese_pairs_new)
                    count = count - 1

            if count == 0:
                return
                    
        backtrack(n, '')

        return output
```


### good solution
```
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []

        def dfs(openP, closeP, s):
            if openP == closeP and openP + closeP == n * 2:
                res.append(s)
                return
            
            if openP < n:
                dfs(openP + 1, closeP, s + "(")
            
            if closeP < openP:
                dfs(openP, closeP + 1, s + ")")

        dfs(0, 0, "")

        return res

```

### 学习到的点

1. 这个题答案用了连续的函数嵌套, 基于存在一个左括号就一定会存在一个右括号的原理，先把左括号加满。在左括号的if条件中连续嵌套函数，然后再依次根据每个左括号的位置加对应的右括号，只要满足当前左括号的数量不小于右括号即可。同样是基于这个条件不停嵌套函数，最底层是只要左括号数等于右括号数且总和小于2n就将生成的括号组合加入到输出中。我的答案太复杂了，只基于一个if条件进行函数嵌套，其实可以学习这个答案，基于多个条件进行嵌套的，这样就不会出现漏掉某种情况的问题。

# 20241122
## Combination Sum

[题目链接](https://leetcode.com/problems/combination-sum/submissions/1459962308/?envType=study-plan-v2&envId=top-100-liked)

### my solution

```
class Solution(object):
    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        output = []
        def find_combination(candidates, target, combination):
            if target == 0:
                combination.sort()
                if combination not in output:
                    output.append(combination)
                return
            min_candidates = min(candidates)
            if target < min_candidates:
                return
            for i in candidates:
                combination_new = combination[:]
                # print('combination_new:{}'.format(combination_new))
                # print('combination:{}'.format(combination))
                combination_new.append(i)
                # print('i:{}'.format(i), 'target:{}'.format(target))
                find_combination(candidates, target - i, combination_new)

        find_combination(candidates, target, [])
        return output
```

### good solution

```
class Solution(object):
    def __init__(self):
        self.res = []
        self.path = []

    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        def backtracking(total,candidates,target,startIndex):
            if total == target:
                self.res.append(self.path[:])
                return
            # if total > target:
            #     return
            for i in range(startIndex,len(candidates)):
                if candidates[i] + total > target:
                    break
                total += candidates[i]
                self.path.append(candidates[i])
                backtracking(total,candidates,target,i)
                total -= candidates[i]
                self.path.pop()
        candidates.sort()  # sort Before backTracking
        backtracking(0,candidates,target,0)
        
        return self.res
```

### 学习到的点
1. 和前几道题类似，也是定义一个函数并在函数内循环调用这个函数
2. 之前不知道为什么第一道题的解答采用了 list_name[:] 这种形式，现在知道了这是为了 deep copy, 当使用了deep copy后，会创建一个新的变量，占用一个新的内存，且对新变量进行改变不会影响原来的变量。而正常我原来使用的 a=b 是shallow copy, 这时候a和b都指向同一个变量，改变a的同时也会改变b。而使用 a=b[:] 则会进行一个deep copy操作，这样改变a的时候不会联动改变b。

# 20241125
## Permutations
[题目链接](https://leetcode.com/problems/permutations/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution(object):
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """

        outputs = []
        def fine_permutation(nums, permutation):
            if len(nums) == 0:
                outputs.append(permutation)
                return
            for i in nums:
                new_permutation = permutation[:]
                new_permutation.append(i)
                new_nums = list(set(nums)-set([i]))
                fine_permutation(new_nums, new_permutation)
            
        fine_permutation(nums,[])
    
        return outputs
```

### 学习到的点
1. 从一个list中减去某部分element
   ```
   list(set(list_1)-set(list_2))
   ```

## N-Queens
[题目链接](https://leetcode.com/problems/n-queens/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution(object):
    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """
        output = []
        matrix = [['.']*n for i in range(n)]
        def backtrack(row, column_of_previous_queen, num_queen, matrix):
            if num_queen == n:
                matrix_copy = ["".join(matrix_row) for matrix_row in matrix]
                output.append(matrix_copy)
                return

            for column in range(n):
                if column in column_of_previous_queen:
                    continue

                queen_indicator = True
                new_queen_x = row - 1
                new_queen_y = column - 1
                while new_queen_x>=0 and new_queen_y >=0:
                    if matrix[new_queen_x][new_queen_y] == 'Q':
                        queen_indicator = False
                    new_queen_x = new_queen_x -1
                    new_queen_y = new_queen_y -1
                    
                new_queen_x = row - 1
                new_queen_y = column + 1
                while new_queen_x>=0 and new_queen_y <n:
                    if matrix[new_queen_x][new_queen_y] == 'Q':
                        queen_indicator = False
                    new_queen_x = new_queen_x -1
                    new_queen_y = new_queen_y +1 

                if queen_indicator == True:
                    matrix_new = matrix[:]
                    matrix_new[row][column] = "Q"
                    
                    column_of_previous_queen_new = column_of_previous_queen[:]
                    column_of_previous_queen_new.append(column)

                    num_queen_new = num_queen + 1
                    backtrack(row+1,column_of_previous_queen_new, num_queen_new, matrix_new)
                    matrix_new[row][column] = "."
                    
                    
        backtrack(0,[], 0, matrix)     

        return output
        
```

### good solution
```
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        cols = set()
        posdig = set()
        negdig = set()
        
        res = []
        
        board = [["."]*n for i in range(n)]
        
        def backtrack(r):
            
            if r==n:
                copy = ["".join(row) for row in board]
                res.append(copy)
                return
            
            for c in range(n):
                
                if c in cols or (r+c) in posdig or (r-c) in negdig:
                    continue
                    
                cols.add(c)
                posdig.add(r+c)
                negdig.add(r-c)
                board[r][c]="Q"
                
                backtrack(r+1)
                
                cols.remove(c)
                posdig.remove(r+c)
                negdig.remove(r-c)
                board[r][c]="."
                
        backtrack(0)
        return res
```

### 学习到的点

1. string 乘 int 可以构造连续的 string， 如 '.' * 5 = '.....'
2. join(list)函数可以把list中的element聚合起来，如 ' '.join([I,love,you]) = 'I love you', ''.join([x,x,x,x,x]) = 'xxxxx'.
3. list无法像numpy那样在一个方框内连续引用，如:
```
a = numpy.array([[1,2],[3,4],[5,6]])
b = [[1,2],[3,4],[5,6]]

则 a[0,1]不会报错 而 b[0,1]会报错，只能用b[0][1]

且list好像不支持直接提取列，如 a[:,0] 会返回 array([1,3,5]) 而 b[:,0]会报错

```
4. 要判断对角线上只存在单独的element，可以看出左上到右下的对角线上的element的 x-y 的值是相等的，同时左下到右上的对角线上的element的 x+y 的值是相等的，具体可以看这个[链接](https://leetcode.cn/problems/eight-queens-lcci/solutions/411529/liang-chong-shi-xian-xiang-xi-tu-jie-mian-shi-ti-2/), 因此只需要通过计算 x-y 和 x+y 并保证其他的element不会存在相同的值即可保证对角线上的独立element.
5. 除了list之外，还可以学习 good solution 中使用的 set()，set会将element保存为{1,2,3}的格式，并通过 set_name.add() 和 set_name.remove()实现element的加和减。
6. 本题在backtrack可以针对每一行进行，因为每一行只会存在一个queen, 所以在每一行遍历所有列来创建queen并进入下一层函数嵌套来判断是否符合条件。
7. 连续的string是无法直接添加或者减少元素的，如'aaaabbbb'无法直接将其中一个a替换成c以实现'aaacbbbb'，good solution是将他们构建为 
```
[[a],[a],[a],[a],[b],[b],[b],[b]]
```
的形式再用 
```
''.join([[a],[a],[a],[a],[b],[b],[b],[b]])
```
来将他们转化回 'aaaabbbb'. 我的答案中借鉴了这个方法

# 20241126

## Subsets
[题目链接](https://leetcode.com/problems/subsets/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution(object):
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        
        outputs = []
        def backtrack(subset, nums, outputs):
                
            if subset not in outputs:
                outputs.append(subset)

            if len(nums) == 0:
                return

            for i in nums:
                subset_new = subset[:]
                subset_new.append(i)
                subset_new.sort()
                nums_new = nums[:]
                nums_new.remove(i)

                backtrack(subset_new, nums_new, outputs)

        backtrack([], nums, outputs)

        return outputs
```

### good solution 1
```
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        subset = []
        def dfs(i):
            if i >= len(nums):
                res.append(subset.copy())
                return
            
            subset.append(nums[i])
            dfs(i+1)

            subset.pop()
            dfs(i+1)

        dfs(0)
        return res
```

### good solution 2

```
class Solution:
    def subsets(self, nums):
        result = [[]]  # Start with the empty subset
        for num in nums:
            result += [subset + [num] for subset in result]
        return result
```

### 学习到的点
1. 我的方法虽然也能获得结果，但复杂度太高，属于非常蠢的方法，不能将outputs连同函数进入backtrack过程，会极大地占用计算资源
2. 这道题的本质就是添加和删去现有的元素，在第一个good solution中，先把nums中的每一个元素依次添加到subset集合中，当backtrack层数达到nums总长度时说明没有新的元素可以加入了，就添加到输出集合中。然后紧接着是利用 .pop()函数删去subset中最后一个元素然后再次进入下一层的backtrack，这样就可以跳过删去的那个element来添加新的element了。如当nums = [1,2,3,4]时, 原本[1,2,3]进入下一层后会添加4变为[1,2,3,4], 然后[1,2,3,4]会被添加给outputs并返回上一层函数，并执行[1,2,3].pop()变为[1,2]，然后再进入下一层添加4变为[1,2,4]并加给outputs. list_name.pop()函数是用于删去指定位置的element的，若无指定位置则删去最后一个。
3. good solution2则是一个炫技之作，在每次便利到nums的一个元素时，会将这个元素加到现有的result中的所有集合中并生成新的result. 如一开始是空集合[],遍历到1时变成[[],[1]],遍历到2时变成[[],[1],[2],[1,2]],遍历到3时变成[[],[1],[2],[1,2],[3],[2,3],[1,2,3]]


## Word Search
[题目链接](https://leetcode.com/problems/word-search/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution(object):
    def exist(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        output = []
        def backtrack(word, last_alphabet_position, previous_alphabet_position, iteration):
            # print(iteration)
            
            if len(output) != 0:
                return
            if len(word) == 0:
                output.append('true')
                return

            alphabet = word[0]
            # print(alphabet)

            length_row_board = len(board)
            length_column_board = len(board[0])

            find_alphabet_position = False
            alphabet_position = []
            if last_alphabet_position == [] and iteration == 0:
                first_alphabet_position = []
                for i in range(length_row_board):
                    for j in range(length_column_board):
                        first_alphabet_position = []
                        find_alphabet_position = False
                        if board[i][j] == alphabet:
                            first_alphabet_position.append([i,j])
                            find_alphabet_position = True
                        
                        if find_alphabet_position == True:
                            # print(first_alphabet_position)
                            new_word = word[:0] + word[(0+1):]
                            # print(new_word)
                            previous_alphabet_position.append(first_alphabet_position[0])
                            backtrack(new_word, first_alphabet_position, previous_alphabet_position, iteration+1)
                            previous_alphabet_position.remove(first_alphabet_position[0])
                            
                        

                if find_alphabet_position == False:
                    if len(output) == 0:
                        output.append('false')
                    return
                
            else:
                
                neg_x_position = last_alphabet_position[0][0] - 1
                pos_x_position = last_alphabet_position[0][0] + 1
                neg_y_position = last_alphabet_position[0][1] - 1
                pos_y_position = last_alphabet_position[0][1] + 1

                # print('neg_x_position: {}'.format(neg_x_position), 'pos_x_position: {}'.format(pos_x_position))
                # print('neg_y_position: {}'.format(neg_y_position), 'pos_y_position: {}'.format(pos_y_position))

                if neg_x_position > 0 :
                    if board[neg_x_position][last_alphabet_position[0][1]] == alphabet and [neg_x_position, last_alphabet_position[0][1]] not in previous_alphabet_position:
                        find_alphabet_position = True
                        alphabet_position.append([neg_x_position,last_alphabet_position[0][1]])

                if pos_x_position < length_row_board:
                    if board[pos_x_position][last_alphabet_position[0][1]] == alphabet and [pos_x_position, last_alphabet_position[0][1]] not in previous_alphabet_position:
                        find_alphabet_position = True
                        alphabet_position.append([pos_x_position, last_alphabet_position[0][1]])

                if neg_y_position > 0:
                    if board[last_alphabet_position[0][0]][neg_y_position] == alphabet and [last_alphabet_position[0][0], neg_y_position] not in previous_alphabet_position:
                        find_alphabet_position = True
                        alphabet_position.append([last_alphabet_position[0][0], pos_y_position])

                if pos_y_position < length_column_board:
                    if board[last_alphabet_position[0][0]][pos_y_position] == alphabet and [last_alphabet_position[0][0], pos_y_position] not in previous_alphabet_position:
                        find_alphabet_position = True
                        alphabet_position.append([last_alphabet_position[0][0], pos_y_position])

                if find_alphabet_position == True:
                    new_word = word[:0] + word[(0+1):]
                    # print(new_word)
                    # print(alphabet_position)
                    previous_alphabet_position.append(alphabet_position[0])
                    backtrack(new_word, alphabet_position, previous_alphabet_position, iteration+1)
                # else:
                #     output.append('false')
                    # return 
                        
        backtrack(word, [], [], 0)

        return output[0] == 'true'
```

### good solution
```
class Solution:
    def exist(self, board, word):
        def backtrack(i, j, k):
            if k == len(word):
                return True
            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
                return False
            
            temp = board[i][j]
            board[i][j] = ''
            
            if backtrack(i+1, j, k+1) or backtrack(i-1, j, k+1) or backtrack(i, j+1, k+1) or backtrack(i, j-1, k+1):
                return True
            
            board[i][j] = temp
            return False
        
        for i in range(len(board)):
            for j in range(len(board[0])):
                if backtrack(i, j, 0):
                    return True
        return False
```

### 学习到的点
1. 我把变量命名太长了，这样会导致代码很长
2. good solution 直接将 backtrack 基于每个不同的条件融入到每一层中，如寻找当前element临近的element是否符合条件的时候就是一个位置一个backtrack()函数，而不是像我一样弄了一大堆的if条件判断，同时判断位置是否符合棋盘的范围完全可以在下一层的backtrack()函数中进行，而我就一定要在一层内判断完，这样相比之下我的代码就很蠢。
3. 每一个字母判断完后，good solution直接将这个位置的字母变为空，这样就保证不会重复回到原来的位置，当结束当前backtrack之前才替换回去，相比之下我又弄了一个数组去存储所有对应字母的位置，这无疑加大了对于内存的消耗，以后要避免这种情况再次出现!!!
4. good solution 直接返回 True 和 False, 而我搞了一个 string， 蠢！！！
5. 最初始的第一个字母的搜索完全可以直接用一个最外层的backtrack()函数来完成，而我又是弄了一个if条件来判断，太蠢了。


# 20241127

## Palindrome Partitioning
[题目链接](https://leetcode.com/problems/palindrome-partitioning/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution(object):
    def partition(self, s):
        """
        :type s: str
        :rtype: List[List[str]]
        """
        outputs = []

        def backtrack(palindrome, s):
            
            if len(s) == 0:
                outputs.append(palindrome[:])
                return
            for i in range(len(s)):
                subset = s[0:i+1]  
                if subset == subset[::-1]:
                    palindrome = palindrome[:]
                    palindrome.append(subset)
                    backtrack(palindrome, s[i+1:])
                    palindrome.pop()

        backtrack([], s)

        return outputs
```

### good Solution
```
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        # s = "aab|"
        # a, ab -> No
        # a, b, c -> Yes
        # aa, b -> Yes
        # aab -> No
        # [[a, b, c], [aa, b]] -> Output
        # SOLUTION
        # TC: 2^N
        # SC: 2^N

        result = []
        lenS = len(s)

        def explore(index, curr):
            if index >= lenS:
                result.append(curr.copy())

            for i in range(index, lenS):
                subStr = s[index:i + 1]
                if subStr == subStr[::-1]:
                    curr.append(subStr)
                    explore(i + 1, curr)
                    curr.pop()

        explore(0, [])
        return result
```

### 学习到的点
1. 对于一个list或者string, string_name[::-1]可以实现从后往前输出, 如 'abc'[::-1] = 'cba'
2. 我的答案消耗了相对多的时间，我想这是因为我把s输入到了每一层backtrack中去，这会导致额外的内存占用，实际上只需要像good solution一样指定一个表示当前位置的index并用于调用s中对应的element即可，单个index占用内存肯定小于整个集合。


## Median of Two Sorted Arrays

[题目链接](https://leetcode.com/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:

        nums_merge = nums1 + nums2 
        nums_merge.sort()

        if len(nums_merge)/2 > int(len(nums_merge)/2):
            median = nums_merge[int(len(nums_merge)/2)]
        else:
            median = (nums_merge[int(len(nums_merge)/2)-1] + nums_merge[int(len(nums_merge)/2)])/2

        return median
```

### 学习到的点:
1. python 的int()是向下取整, python3的int()是向上取整。


# 20241128
## Search in Rotated Sorted Array
[题目链接](https://leetcode.com/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
太简单了以至于不需要good solution
```
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        find_target = False
        for i in range(len(nums)):
            if nums[i] == target:
                find_target = True
                target_index = i
        if find_target == False:
            target_index = -1

        return target_index
```

### 学习到的点
1. 虽然代码中没用到。但还是值得一记。返回一个list中特定元素的index可以用函数 list_name.index(target_element)

## Find First and Last Position of Element in Sorted Array
[题目链接](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/1465211714/?envType=study-plan-v2&envId=top-100-liked)

### my solution
同样太简单了所以不需要good solution
```
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:

        find_first_target = False
        find_last_target = False
        number_of_target = 0

        if len(nums) == 1:
            if nums[0] == target:
                find_first_target = True
                find_last_target = True
                first_target_index = 0
                last_target_index = 0
        else:
            for i in range(len(nums)):
                if nums[i] == target:
                    if find_first_target == False:
                        find_first_target = True
                        first_target_index = i
                        number_of_target = number_of_target + 1
                    else:
                        find_last_target = True
                        last_target_index = i
                        number_of_target = number_of_target + 1
        if find_first_target == False:
            first_target_index = -1
        if find_last_target == False:
            last_target_index = -1
        if number_of_target == 1:
            last_target_index = first_target_index
        output = [first_target_index,last_target_index]

        return output
```

### 学习到的点
1. 我一开始忽略了list中只有一个element符合target的情况下 first 和 last 都对应同一个index这种情况


## Search Insert Position
[题目链接](https://leetcode.com/problems/search-insert-position/submissions/1465233661/?envType=study-plan-v2&envId=top-100-liked)

### my solution
题目难度不高，所以没有good solution
```
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:

        find_target = False
        for i in range(len(nums)):
            if nums[i] == target:
                find_target = True
                target_index = i
        if find_target == False:
            nums.append(target)
            nums.sort()
            target_index = nums.index(target)

        return target_index
```

## Search a 2D Matrix

[题目链接](https://leetcode.com/problems/search-a-2d-matrix/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
感觉也是没什么难度，不需要good solution
```
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        find_target = False
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == target:
                    find_target = True
        return find_target
```

# 20241129

## Binary Tree Maximum Path Sum
[题目链接](https://leetcode.com/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
想的复杂了，没做出来

### good solution
```
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        self.max_sum = float("-inf")

        def max_gain(node):
            if not node:
                return 0
            
            left_gain = max(max_gain(node.left),0)
            right_gain = max(max_gain(node.right),0)

            current_sum = node.val + left_gain + right_gain
            self.max_sum = max(self.max_sum,current_sum)

            return node.val + max(left_gain,right_gain)
        
        max_gain(root)
        return self.max_sum
```

### 学习到的点
1. Binary Tree 本质上就是一个节点有往后有两个分支, 当没有分支的时候就结束了，我还考虑什么把一维数组和 Binary Tree 上每一层的节点对应，完全没有这个必要
2. good solution 构造了一个全局变量来记录最大的总和，然后不停地从每个节点的左分支和右分支往后迭代, 每个节点的左右分支都判断是否比0大，比0小说明会照成负收益，就直接忽略。同时每个节点都计算左分支和右分支的收益加当前节点的总和，并和全局变量来做比较。这样当某个节点的值加左右分支的和是最大的时候，就会存储在全局变量中。
3. 分支结束的判断一句就算没有后续节点了
4. 暂时还不清楚怎么把输入的一维数组 root 转化为 形如左右分支的结构的， 可能要和姐夫讨论一下。

## Find Minimum in Rotated Sorted Array
太简单了，不需要回顾

## Binary Tree Inorder Traversal
[题目链接](https://leetcode.com/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
太简单所以不需要good solution
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        self.val = []

        def find_order(node):
            if not node:
                return
            left_node = find_order(node.left)
            self.val.append(node.val)
            right_node = find_order(node.right)
            
        
        find_order(root)

        return self.val

```

## Validate Binary Search Tree
[题目链接](https://leetcode.com/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没做对！！！！
我的答案一开始没有考虑到跨维度的节点之间仍然要满足限制条件的情况, 如 [5,4,6,null,null,3,7]中3是右边分支的第二维的左分支，但这个位置也要满足大于最初始的5，所以这时要返回 False, 而我一开始的代码没有考虑到这个情况。后来报错之后，也找不到怎么样可以用一个更好的方法来传递这个比较的变量，因为我的逻辑是从底层往回传的。

### good solution
```
class Solution:
    res=True
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def dfs (r,mx,mn):
            if r.right:
                if r.right.val<=r.val or r.right.val>=mx:
                    self.res =  False

                dfs(r.right,mx ,r.val)
            if r.left:
                if r.left.val>=r.val or r.left.val<=mn:
                    self.res=  False
                dfs(r.left,r.val,mn)

        dfs(root,2**31,-2**31-1)
        return self.res
```


### 学到的东西
1. 我的逻辑估计想错了，我不应该从底层往回return最大最小限制值，而应该直接从顶层往底层在函数的input中输入最大最小范围，
2. 同时 右边分支每一层的最大就应该是输入的最大，而最小则限制为当前节点的值。 同理， 左边分支每一层的最小应该就算输入的最小，而最大限制则为当前节点的值，这样当遇到 [5,4,6,null,null,3,7] 这种情况时，先右边分支再左边分支，就可以将初始的节点值 5 传递给所有后续的右边分支作为所有右边分支最小值的限制！！！！
3. 之后再重新做一次这个题！！！！

# 20241130

## Symmetric Tree

### my solution
```
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        self.max_layer = 0
        def calculate_max_layer(nood,j):
            if self.max_layer < j:
                self.max_layer = j
            if nood.right:
                calculate_max_layer(nood.right, j + 1)
            if nood.left:
                calculate_max_layer(nood.left, j + 1)
        calculate_max_layer(root,0)

        self.layer_array = [[] for i in range(self.max_layer+1)]

        def dfs(nood,i):
            if nood is None:
                return
            if i == 0 and ((nood.right is None and nood.left is not None) or (nood.left is None and nood.right is not None)):
                self.unsymetric = True

            if nood.left:
                self.layer_array[i].append(nood.left.val)
            elif nood.left is None:
                self.layer_array[i].append(None)
            dfs(nood.left, i + 1)

            if nood.right:
                self.layer_array[i].append(nood.right.val)
            elif nood.right is None:
                self.layer_array[i].append(None)
            dfs(nood.right, i + 1)


        dfs(root,0)
        self.output = True
        print(self.layer_array)
        for i in range(len(self.layer_array)):
            length = len(self.layer_array[i])

            left_side = self.layer_array[i][:int(length/2):]
            right_side = self.layer_array[i][:int(length/2-1):-1]
            if left_side != right_side:
                self.output = False
            
        
        return self.output
```

### good solution

```
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        return self.isMirror(root.left, root.right)

    def isMirror(self, t1: Optional[TreeNode], t2: Optional[TreeNode]) -> bool:
        if not t1 and not t2:
            return True
        if not t1 or not t2:
            return False
        return (t1.val == t2.val and
                self.isMirror(t1.left, t2.right) and
                self.isMirror(t1.right, t2.left))
```

### 学到的东西
1. my solution 是用了一个取巧的方法，又是传统的创建数组存储然后再比较那一套，这样会导致内存的额外占用。
2. 我一开始不知道怎么解决同时验证左分支和右分支的问题。
3. good solution 采用在函数中直接输入左右分支，然后左分支的左子分支和右分支的右子分支比较，左分支的右子分支和右分支的右子分支进行比较。然后往后迭代。

# 20241202

## Binary Tree Level Order Traversal
[题目链接](https://leetcode.com/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution

```
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        self.max_layer = 0
        def calculate_max_layer(nood,j):
            if nood is None:
                return
            if self.max_layer < j:
                self.max_layer = j
            if nood.right:
                calculate_max_layer(nood.right, j + 1)
            if nood.left:
                calculate_max_layer(nood.left, j + 1)
        calculate_max_layer(root,0)

        self.layer_array = [[] for i in range(self.max_layer+1)]

        def dfs(nood,i):
            if nood is None:
                return

            if i == 0:
                self.layer_array[i].append(nood.val)
            if nood.left:
                self.layer_array[i+1].append(nood.left.val)
            dfs(nood.left, i + 1)

            if nood.right:
                self.layer_array[i+1].append(nood.right.val)
            dfs(nood.right, i + 1)

        dfs(root,0)

        if len(self.layer_array[0]) == 0:
            self.layer_array = []

        return self.layer_array
```
        
### good solution
```
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        list1=[]
        q=deque()
        q.append(root)
        while q:
            level=[]
            for i in range(len(q)):
                poping=q.popleft()
                if poping:
                    level.append(poping.val)
                    q.append(poping.left)
                    q.append(poping.right)
            if level:
                list1.append(level)
        return list1
```

### 学到的东西

1. 好多good solution 都用的deque(), 这是python库 collections 中定义的一个类, 可以实现两端操作(即双端队列)。deque()可以实现从队列的头部删去元素(popleft)，也可以从队列的尾部删去元素(pop)。根据评论中的解释, popleft()只会消耗O(1)的时间复杂度, 而使用list并结合pop()会消耗O(n)的时间复杂度。
2. 每轮while循环中, 都会把当前节点从q中提取出来加入到level中并且将左子节点和右子节点加入到q中进入下一轮while循环。


# 20241203

## Maximum Depth of Binary Tree
[link](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution

```
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        self.max_layer = 0
        def calculate_max_layer(nood,j):
            if nood is None:
                return
            if self.max_layer < j:
                self.max_layer = j
            if nood.right:
                calculate_max_layer(nood.right, j + 1)
            if nood.left:
                calculate_max_layer(nood.left, j + 1)
        
        calculate_max_layer(root,0)
        if root is None:
            self.max_layer = -1
        return self.max_layer + 1
```

### good solution
```
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        leftDepth = self.maxDepth(root.left)
        rightDepth = self.maxDepth(root.right)
        return 1 + max(leftDepth, rightDepth)
```

### 学到的东西
1. 我的答案构造了一个额外的变量 self.max_layer 去存储最大的level, 其实可以像 good solution 那样每次运行函数返回最大 level就好了
2. good solution是直接一开始就追踪到最底层, 然后往回回溯的时候每一层level的返回当前深度值都会 +1。这样返回到最顶层时返回值就正好是最大深度.
3. good solution针对 nood = None 的情况是直接返回0, 这正好和正常情况的 return 互相对应了， 而不需要像我那样还要多一个特定的 if条件句来判断。

##  Construct Binary Tree from Preorder and Inorder Traversal
[link](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        self.max_layer = 0
        def find_max_layer(preorder, inorder, layer):
            if len(preorder) == 0:
                if self.max_layer < layer:
                    self.max_layer = layer
            if len(preorder) > 0:
                first_nood = preorder[0]
                index_first_nood = inorder.index(first_nood)
                left_tree = inorder[:index_first_nood]
                right_tree = inorder[index_first_nood+1:]
                
                left_index = [preorder.index(i) for i in left_tree]
                left_index.sort()
                left_preorder = [preorder[j] for j in left_index]
                find_max_layer(left_preorder, left_tree, layer + 1)
                
                right_index = [preorder.index(i) for i in right_tree]
                right_index.sort()
                right_preorder = [preorder[j] for j in right_index]
                find_max_layer(right_preorder, right_tree, layer + 1)

        find_max_layer(preorder, inorder, 0)

        self.layer_array = [[] for i in range(self.max_layer)]

        def construct_tree(preorder, inorder, layer):
            if len(preorder) == 1:
                self.layer_array[layer].append(preorder[0])
                if layer < self.max_layer - 1:
                    diff = self.max_layer - 1 - layer
                    for i in range(diff):
                        for j in range(2*(i+1)):
                            self.layer_array[layer+i+1].append(None)
                    # self.layer_array[layer+1].append(None)
                return
            if len(preorder) > 0:
                first_nood = preorder[0]
                self.layer_array[layer].append(preorder[0])
                index_first_nood = inorder.index(first_nood)
                left_tree = inorder[:index_first_nood]
                right_tree = inorder[index_first_nood+1:]
                
                left_index = [preorder.index(i) for i in left_tree]
                left_index.sort()
                left_preorder = [preorder[j] for j in left_index]
                construct_tree(left_preorder, left_tree, layer+1)
                
                right_index = [preorder.index(i) for i in right_tree]
                right_index.sort()
                right_preorder = [preorder[j] for j in right_index]
                construct_tree(right_preorder, right_tree, layer+1)
        construct_tree(preorder, inorder, 0)
        
        last_array = []
        for i in self.layer_array:
            for j in i:
                last_array.append(j)
        
        return last_array
```

### good solution
```
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:

        preorder = deque(preorder)

        def build(preorder, inorder):
            if inorder:
                idx = inorder.index(preorder.popleft())
                root = TreeNode(inorder[idx])

                root.left = build(preorder, inorder[:idx])
                root.right = build(preorder, inorder[idx+1:])

                return root

        return build(preorder, inorder)
```

### 学到的东西

1. 从good solution 中可以看出，根本不需要像我那样又是算总 layer数又是根据layer数一层层地去创建对应layer array, 直接根据逻辑将 preorder的第一个element作为当前节点, 然后用TreeNode这个class去定义它，然后将其余的左右子分支根据inorder中在当前nood左边的为左子分支, 右边的为右子分支, 迭代调用build函数创建即可。
2. 同样good solution也是一开始就将preorder指定为 deque 双端序列，根据作者解释，这是为了更好的 popping element，因为每一次创建当前 nood 都需要将preorder的第一个element popping出来。

## Convert Sorted Array to Binary Search Tree
[link](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)


### my solution
虽然这是一个easy题目，我也大概想到和上一道可以采用差不多的逻辑，但是我没想到可以直接用self.函数本身 来实现循环调用

### good solution
```
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional['TreeNode']:
        if not nums:
            return None
        mid = len(nums) // 2
        root = TreeNode(nums[mid])
        root.left = self.sortedArrayToBST(nums[:mid])
        root.right = self.sortedArrayToBST(nums[mid + 1:])
        return root
```

### 学到的东西
1. 可以在函数内直接用self.函数本身来实现循环调用

# 20241204

## Flatten Binary Tree to Linked List
[link](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案并不是完全自己想出来的，而是先看了一个答案的长度和循环逻辑，然后在知道存在一个中间变量且整个代码量不大的情况下，再自己把最后的节点互相替代部分补上的
```
class Solution:
    def __init__(self):
        self.prev = None
    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if root is None:
            return None
        
        self.flatten(root.right)
        self.flatten(root.left)

        root.left = None
        root.right = self.prev
        self.prev = root
```

### 学到的东西
1. 没想到可以将节点值大的节点用一个中间变量存储起来，然后将节点值小一点的节点的左边设为None, 节点的右边设为存储起来的节点值

## Binary Tree Right Side View
[link](https://leetcode.com/problems/binary-tree-right-side-view/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案就是最好的答案
```
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        self.max_layer = -1
        self.output = []
        def right_side_view(root, layer):
            if not root:
                return
            if layer > self.max_layer:
                self.output.append(root.val)
                self.max_layer = layer
            right_side_view(root.right, layer+1)
            right_side_view(root.left, layer+1)
        right_side_view(root, 0)

        return self.output
```

## Invert Binary Tree

[link](https://leetcode.com/problems/invert-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if root is None:
            return 
        left_root = self.invertTree(root.left)
        right_root = self.invertTree(root.right)
        
        root.left = right_root
        root.right = left_root

        return root
```

## Kth Smallest Element in a BST
[link](https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        self.all_element = []
        def add_element(node):
            if node is None:
                return
            self.all_element.append(node.val)

            add_element(node.left)
            add_element(node.right)
        
        add_element(root)
        self.all_element.sort()

        return self.all_element[k-1]
        
```

### good solution

```
class Solution(object):
    def kthSmallest(self, root, k):
        self.count = 0
        self.result = 0
        self.inorderTraversal(root, k)
        return self.result
    
    def inorderTraversal(self, node, k):
        if not node or self.count >= k:
            return
        
        self.inorderTraversal(node.left, k)
        
        self.count += 1
        if self.count == k:
            self.result = node.val
            return
        
        self.inorderTraversal(node.right, k)

```

### 学到的东西
1. 我用了一个取巧的方法，就算将所有element都存起来再排序，这样会导致较高的空间占用
2. 像good solution这样，按照binary tree本身的分布逻辑先左分支后右分支地去提取指定第k个node的值会比较节省计算资源。

## Lowest Common Ancestor of a Binary Tree
[link](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案实际上是看了一个good solution的一部分才做出来的，所以严格意义上不算我做出来的，所以这题直接看good solution!!!!!


### good solution
```
class Solution:
  def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
    if not root or root == p or root == q:
      return root

    l = self.lowestCommonAncestor(root.left, p, q)
    r = self.lowestCommonAncestor(root.right, p, q)

    if l and r:
      return root
    return l or r
```

### 学到的东西

1. 其实这道题的目的就是确认某个节点的子分支节点中是否拥有两个指定的节点，当找到指定的节点就是当前迭代到的节点时，就可以直接返回了，因为此时对于上一层节点来说，它的子节点一定包含其中一个指定的节点。同时要注意到，因为是二元分支，所以一个祖先的子节点中如果包含两个指定的节点，那么一定是一个在左分支一个在右分支，或者这个祖先本身就是指定的节点中的一个。
2. 这时候就要分情况讨论了，如果其中一个指定的节点正好就是另一个指定的节点的子节点，那么我们可以直接返回那个祖先节点而不用再追踪那个后辈节点了，因为后辈节点一定在祖先节点的子节点中。
3. 具体到题目一开始举的例子，假设其中一个指定的节点就是最外层的节点 3， 那么我们不用管另一个节点是什么，直接将3作为值返回就行，因为另外一个指定的节点一定是 3 的子节点。
4. 如果两个指定的节点彼此之间没有任何 祖先 和后辈的关系，那么也就意味着他们一定分别来自于某个节点的左右两个分支，所以我们只要我们找到某个节点的左右分支中都分别存在着指定的节点，我们就返回这个节点就好
5. 具体到代码中，可以看到good solution 先判断某个分支是否达到了尽头或者当前节点正好是指定的节点中的一个，如果达到了尽头，说明当前分支中不存在指定的节点，则返回值是None。如果对应指定的节点，则返回值是指定的节点。然后迭代是一个输入左分支进行迭代，一个输入右分支进行迭代。如果返回的左右分支都是指定的节点，则说明指定的节点一定分别在当前节点的左右两个子分支中，对应第四点的情况，那么这个节点就是我们要找的祖先节点。如果只有其中一个返回值是指定的节点，另一个是None, 那么说明当前节点的子节点中只包含一个指定的节点，我们要去寻找当前节点的上一层节点的另外一个分支，这时候就只把指定的节点返回回去而不要返回None,所以代码最后一行 ```return 1 or r``` 的意思是如果不是两个返回值都是指定的节点这种情况，那么只需要返回对应指定节点的那个返回值就好。因为祖先节点的子节点中一定包含另外一个指定节点。
6. example 2中 一个指定的节点4 是另一个指定的节点 5 的子节点，而代码运行到5后发现 5正好是一个指定的节点，就直接将5返回，然后回到 节点3 去搜索节点3的右分支，发现节点4并不存在于节点3的右分支中，那么节点4就一定存在于节点3的左分支中，也就是说节点4一定存在于节点5的两个分支中的一个。这时候节点3的左返回值是节点5，右返回值是None(代表右分支中不存在指定的节点), 那么节点3的最终返回值就是节点5了。 也就是说节点5就一路往回传知道作为最终的输出。
7. 假设 其中一个指定的节点在节点3的左分支中，另一个指定的节点在节点3的右分支中，这时候就会满足左右分支返回值都是节点的情况，那么就说明两个指定的节点正好分别在节点3的左右两个子分支中，那么节点3就是它们的祖先。这时候就根据if条件返回节点3

# 20241205

## Path Sum III

[link](https://leetcode.com/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我有想到是否要加一个指示器表示当前node是否参加了计算，但还是看了答案才确定的， 所以我的答案严格意义上来说也不算完全是自己完成的
```
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        self.output = 0
        def cal_sum(node,target_sum,curr_sum, include):
            if node is None:
                return

            curr_sum = curr_sum + node.val

            if curr_sum == target_sum:
                
                self.output = self.output + 1
        
                
            
            cal_sum(node.left, target_sum, curr_sum, True)
            cal_sum(node.right, target_sum, curr_sum, True)

            if not include:
                cal_sum(node.left, target_sum, 0, False)
                cal_sum(node.right, target_sum, 0, False)
        cal_sum(root,targetSum,0, False)
        
        return self.output
```

### good solution

```
class Solution:
    def pathSum(self, root: Optional[TreeNode], target: int) -> int:
        def dfs(r,t,include):
            if r is None: return 0
            count=0
            if r.val==t: count+=1
            
            count += dfs(r.left,t-r.val,True) + dfs(r.right,t-r.val,True)

            if not include: count += dfs(r.left,t,False) + dfs(r.right,t,False)
            
            return count

        return dfs(root,target,False)
```

### 学到的东西
1. 我自己的答案其实已经完成了绝大部分，但一直由于没办法解决重复调用某组节点组合的问题，导致一直报错。像我原来的答案是没有 ```if not include``` 这个if条件句的，这样就会导致如果有非常深层的节点组合，会被 前两行的 cal_sum() 调用一次，然后再被后两行的 cal_sum() 再调用一次。
2. 我在思考怎么解决的时候有想到是否要加个指示器来保证以每个节点为开始的 和 计算只进行一次，但是是在看了good solution后才完全确定的。 用了一个include来表示当前节点是否参与了 和 计算， 如果为False，则表示 进入下个节点的 curr_sum 为0，即当前节点没有被加到 curr_sum 中，通过这样就保证了以每个节点开始的组合计算不会重复!!!! 


## Diameter of Binary Tree
[link](https://leetcode.com/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
```
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        self.max_diameter = 0
        def calc_diameter(node,include):
            if node is None:
                return 0

            left_length = calc_diameter(node.left,True)
            right_length = calc_diameter(node.right,True)


            if self.max_diameter < left_length + right_length:
                self.max_diameter = left_length + right_length
                
            
            return max(left_length,right_length) + 1
        
        calc_diameter(root,False)
        return self.max_diameter     
```

### good solution
```
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        # Define a recursive function to calculate the diameter
        def diameter(node, res):
            # Base case: if the node is None, return 0
            if not node:
                return 0
            
            # Recursively calculate the diameter of left and right subtrees
            left = diameter(node.left, res)
            right = diameter(node.right, res)

            # Update the maximum diameter encountered so far
            res[0] = max(res[0], left + right)
            
            # Return the depth of the current node
            return max(left, right) + 1
        
        # Initialize a list to hold the maximum diameter encountered
        res = [0]
        # Call the diameter function starting from the root
        diameter(root, res)
        # Return the maximum diameter encountered
        return res[0]
```

### 学到的东西
1. 基本上本题的思路就是追踪到每一个分支的最底层，然后往回返回距离，没返回一层就加1，最底层为0，最底层返回倒数第二底层时距离+1变为1。
2. 原来还模仿上一题多加了一组迭代，当include为False时候进入第二组迭代，后来发现并不需要，因为会自动遍历所有的节点而不存在重复问题。
3. 返回值选择左分支和右分支中大的那个加1返回

## Longest Palindromic Substring

### my solution
我的结果虽然是对的，但时间复杂度太高
```
class Solution:
    def longestPalindrome(self, s: str) -> str:
        s_inv = s[::-1]
        max_length = 0
        output=''
        if len(s) <= 1:
            return s
        for i in range(len(s)):
            
            for j in range(len(s) - i):
                str = s[j:j+i+1]
                if str == str[::-1]:
                    if max_length < i+1:
                        output = str
                        max_length = i+1
                
        return output
        
```

### good solution
```
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n=len(s)
        if n==1:
            return s
        res=""
        for i in range(n):
            cur=s[i]
            left,right=i-1,i+1  
            while right<n and s[right]==s[i]:
                cur+=s[i]
                right+=1          
            while left>=0 and right<n and s[left]==s[right]:
                cur=s[left]+ cur +s[left]
                right+=1
                left-=1            
            if len(cur)>len(res):
                res=cur
        return res
```

### 学到的东西
1. 对比我的答案和good solution, 不知道是不是 for循环占用的内存比 while循环多，我的答案逻辑上是蛮直观的反正， good solution虽然占用时间少，但是理解起来难

# 20241207

## Longest Valid Parentheses
[link](https://leetcode.com/problems/longest-valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没做出来，看good solution的答案和笔记

### good Solution 1
stack方法
```
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]  # Base index
        max_length = 0

        for i, char in enumerate(s):
            if char == '(':
                stack.append(i)
            else:
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    max_length = max(max_length, i - stack[-1])
        
        return max_length
```

### good solution 2
Daynamic Programming方法
```
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        dp = [0] * len(s)
        max_length = 0

        for i in range(1, len(s)):
            if s[i] == ')':
                if s[i - 1] == '(':
                    dp[i] = (dp[i - 2] if i >= 2 else 0) + 2
                elif i - dp[i - 1] > 0 and s[i - dp[i - 1] - 1] == '(':
                    dp[i] = dp[i - 1] + (dp[i - dp[i - 1] - 2] if i - dp[i - 1] >= 2 else 0) + 2
                max_length = max(max_length, dp[i])
        
        return max_length
```

### 学到的东西
1. 我一直在想用 左括号表示正数， 右括号表示负数的想法，然后计算有效步长，搞了一大堆的指示器和if条件句，还没成功，属实太傻逼了
2. good solution 1 的主要思想是利用堆栈，每次有一个 左括号，就在堆栈array里添加一个当前的index。 然后每有一个 右括号，就删去堆栈array里的上一个存储的index。这个删去动作分两种情况，第一种情况是上一个存储的index是左括号的index，这时候删去就代表这已经构成了一个完整的括号对，可以从堆栈array中删去了，这样后面计算有效括号数的时候 i-stack[-1] 得到的距离就代表这之间所有有效的括号对组合而成的距离。第二种情况是上一个存储的index是右括号的index，这时候就代表上一轮中右括号的数量比左括号多，所以之前的都是无效的，那我这一轮再加个右括号那还是无效的，举例来说，只要没有左括号，连续3个无效的右括号和连续无效的两个右括号实际都是无效的，而我们只需要知道最后一个无效的右括号的index，到时候出现新的有效的右括号时，计算的时候把有效的右括号index - 最后一个无效的右括号index就可以得到有效的括号对距离。所以这里就把上一个无效的右括号的index删去，再在后面将新的无效的右括号的index添加进去。
3. 当当前迭代到的符号是右括号，且堆栈数组中没有存储任何stack的时候，说明两种情况，要么是刚好上一个右括号正好和最后一个没有匹配的左括号组成了一个有效的括号对然后被从堆栈array中删去了，要么是上一个无效的右括号被直接如第二点中解释的那样被直接删去了，这时候当前迭代的右括号就是一个新的无效的右括号，那就把这个新的无效的右括号的index存进去。
4. 当当前迭代到的符号是右括号且当前stack数组中还包含有之前存储着的index时，说明存储的index要么是上一个还没匹配的左括号的index，要么是上一个无效的右括号的index, 无论哪种情况，有效的括号长度都等于当前index减去堆栈array中存储的最后一个element中的index.
5. good solution 2用的是daynamic programming的方法，具体想法就是创建一个和s一样长度的array，然后每个element存储有效的括号距离。同样是每次循环到右括号的时候，如果上一轮循环的是左括号，则正好构成一个括号对，那动态array同样位置的element中存储的有效括号距离就+2，那如果上一轮循环不是左括号，那么就说明上一轮存储的是右括号，那么上一轮存储的右括号所对应的动态array中的element存储的就是上一轮循环中的有效括号距离，这个距离如果是0，那么就说明上一个右括号是无效的右括号，不构成任何有效的括号对，如果距离大于0，则说明之前已经有对应间距的有效括号，我们要再扣除这个有效的括号距离，然后判断再前一个括号是否是左括号，如果是左括号，则说明又构成一个有效的括号对，这样在当前动态array存储的有效括号距离=上一个动态arrya的element存储的有效括号距离+上一个空闲的左括号前一个动态array存储的有效括号距离+新的括号对代表的2

## Unique Paths
[link](https://leetcode.com/problems/unique-paths/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案就是最好的答案
```
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        grid = [[0]*n]*m
        for i in range(m):
            grid[i][0] = 1
        for j in range(n):
            grid[0][j] = 1
        for k in range(m-1):
            for l in range(n-1):
                grid[k+1][l+1] = grid[k+1][l] + grid[k][l+1]
        
        return grid[m-1][n-1]
```

### good solution
逻辑差不多，都是先创建第一行和第一列全为1，然后后面的element为上和左的element相加
```
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:

        aboveRow = [1] * n

        for _ in range(m - 1):
            currentRow = [1] * n
            for i in range(1, n):
                currentRow[i] = currentRow[i-1] + aboveRow[i]
            aboveRow = currentRow
        
        return aboveRow[-1]
```


## Minimum Path Sum
[link](https://leetcode.com/problems/minimum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案就是最好的答案！！！！
```
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == 0:
                    if j > 0:
                        grid[i][j] = grid[i][j] + grid[i][j-1]
                if j == 0:
                    if i > 0:
                        grid[i][j] = grid[i][j] + grid[i-1][j]

                if i > 0 and j > 0:
                        grid[i][j] = grid[i][j] + min(grid[i][j-1], grid[i-1][j])
        
        return grid[-1][-1]
```
## Climbing Stairs
[link](https://leetcode.com/problems/climbing-stairs/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案就是最好的答案！！！！
```
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2:
            return n
        list = [0]*n
        list[0] = 1
        list[1] = 2
        for i in range(2,n):
            list[i] = list[i-1] + list[i-2]
        
        return list[-1]
```

## Edit Distance

[link](https://leetcode.com/problems/edit-distance/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没做出来！！！！，没想到要创建一个分别以两个string的长度为维度二维矩阵来计算

### good solution
[作者的解释](https://leetcode.com/problems/edit-distance/solutions/3230662/clean-codes-full-explanation-dynamic-programming-c-java-python3/?envType=study-plan-v2&envId=top-100-liked)
```
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m = len(word1)
        n = len(word2)
        # dp[i][j] := min # Of operations to convert word1[0..i) to word2[0..j)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            dp[i][0] = i

        for j in range(1, n + 1):
            dp[0][j] = j

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1

        return dp[m][n]
```
### 学到的东西
1. 根本没想到要创建一个二维矩阵来计算，还在想用老一套的列各种if条件来一步一步推导，傻逼！！！！
2. 作者将word1的长度+1设为二维矩阵的行的维度，将word2的长度+1设为二维矩阵的列的维度，这样就可以将string的每个字母都对应到矩阵中的第一行或第一列上，然后用两个for循环进行word1和word2的每个字母间进行两两的判断，
3. 当在当前格子进行题目中提到的替换，删去和添加其中一个操作时，当前格子的操作数分别对应 ```dp[i - 1][j - 1]```, ```dp[i][j - 1]```,```dp[i - 1][j]```这三个相邻格子的操作数+1
4. 如果两个字母之间是一样的，则表示不需要变化，则将上一对字母匹配所对应的操作数赋给当前格子: ```dp[i][j] = dp[i - 1][j - 1]```。如果两个字母之间不一样，则要选择上面所说的三个相邻格子中所行操作数最小的那一个的基础上进行操作。
5. 最终右下角格子的数字就是最简单的操作数
6. 这道题不需要我真的去把word1替换成word2再在这个过程中计算实际所需的操作数，讲白了脑子里还是没有真正融入daynamic programming的思维！！！！！

## Pascal's Triangle
[link](https://leetcode.com/problems/pascals-triangle/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案就是最好的答案
```
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        output = []
        for i in range(1,numRows+1):
            row = [1]*i
            if i > 2:
                for j in range(i):
                    if j > 0 and j < i-1:
                        row[j] = output[i-2][j-1] + output[i-2][j]
            
            output.append(row)
        
        return output
```


# 20241208

## Word Break

### my solution
我的思路是基于Edit Distance的方法，将wordDict中的每个word都使用Edit Distance的思路和输入的string进行比较, 然后如果匹配成功则从输入的string中删掉当前word。思路感觉上没什么问题，但是对于一些极端情况就很难处理，比如 输入是 ```'ccaccc'``` 而 wordDist中是 ```['cc','ac']```, 这样当我用 ```'cc'```匹配成功后，从 输入的string中删去的是从左至右遇到的cc，即会得到 ```'__a__c'```，而不是 ```'__ac__'```，这样就不符合题目的要求了其实
```
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        output = False
        s_backup = s[:]
        s_indicator = s[:]
        while len(wordDict) > 0:
            for word in wordDict:
                if word not in s_indicator:
                    print('yes')
                    continue
                m = len(s)
                n = len(word)
                dp = [[0] * (n + 1) for _ in range(m + 1)]
                
                for j in range(1, n + 1):
                    for i in range(1, m + 1):
                        if word[j-1] == s[i-1]:
                            dp[i][j] = dp[i-1][j-1] + 1
                
                max_value = 0
                for i in range(1, m + 1): 
                    for j in range(1, n + 1):
                        if max_value < dp[i][j]:
                            max_value = dp[i][j]

                # print(dp)
                # print(s)
                # print(word)
                # print(max_value)
                if max_value == len(word):
                    s_indicator = s.replace(word,'_')
                    s = s.replace(word,'')
                print(s)
                print(s_indicator)
            
            if len(s) == 0:
                output = True
                break
            if len(s) > 0:
                wordDict = wordDict[1:]
                s = s_backup[:]
                s_indicator = s_backup[:]
        
        return output
        
```

### good solution
```
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True
        max_len = max(map(len, wordDict))  # The maximum length of a word in the dictionary

        for i in range(1, n + 1):
            for j in range(i - 1, max(i - max_len - 1, -1), -1): # Only consider words that could fit
                if dp[j] and s[j:i] in wordDict:
                    dp[i] = True
                    break

        return dp[n]
```

### 学到的东西
1. good solution 用的才是正常的 daynamic programming的方法，作者首先创建了一个和输入的string同长度的array作为 动态array来表示输入string的哪一部分可以正好被 wordDist 中的单词表示。
2. 另一个学到的东西是一个 map操作, map(function, object)可以持续地对object里的所有element迭代地执行操作。 good solution 中先用  ```map(len, wordDict)```来计算wordDict中每个word的长度，然后用```max()```来提取最长的长度值
3. 本题的外循环遍历创建的动态array的每个元素, 然后内循环循环从当前外循环遍历到的当前位置 i 往回遍历至word长度的最大值的index, 即假设 i=6，max_len=4, 则 j=5,4,3,2, 当往回遍历的位置对于动态array的element正好是True且输入的string从 i到j 的位置正好对应一个word时候，则可以判断输入string的这一段substring正好对应一个word.
4. 内循环的的```max(i - max_len - 1, -1)```是指当j往回遍历的时候，如果从 i-1 往回走 max_len 得到的值小于 -1，说明当前i所对应的index小于max_len, 假设 max_len=4， 当i=1，2，3的时候就会出现这种情况，这里作者加了一个限制，就是至多往回遍历只能遍历到输入string的开头第一个字母，不会遍历到输入string的结尾字母，所以提取 i - max_len - 1 和 -1 中大的那个, -1就代表结尾最后一个element的index。
5. 作者创建动态array的时候，把第一个element```dp[0]```设置为True, 这样在初始比较的时候，最多能往回遍历到0，即初始位置，然后判断从初始位置往后第几位所代表的substring可以在wordDist中找到对应项。以题目的例子为举例，输入的string为 ```'leetcode'```，wordDist中包含的第一个word是```'leet'```，那么外循环到i=4，j=0的时候就会找到匹配，这时候dp[4]会被设为True。然后再重复这个过程，在 i=8，j=4的时候会再次找到匹配, 然后dp[8]会被设为True并最终作为返回项.


# 20241227

## Move Zeroes
[link](https://leetcode.com/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我一开始的代码没有用两点法做，用的pop()配合append()来做的
```
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)

        index = 0

        while index < n:
            if nums[index] == 0:
                nums.pop(index)
                nums.append(0)
                n = n - 1
            else:
                index = index + 1
```
后面看了good solution的逻辑写了自己的代码
```
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)

        left = 0
        right = 0
        while right < n:
            if right == left:
                right = right + 1
                continue
            if nums[left] == 0 and nums[right] !=0:
                nums[left] = nums[right]
                nums[right] = 0
                left = left + 1
            if nums[right] == 0:
                right = right + 1
            if nums[left] != 0:
                left = left + 1

```

### good solution
```
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        left = 0

        for right in range(len(nums)):
            if nums[right] != 0:
                nums[right], nums[left] = nums[left], nums[right]
                left += 1
        
        return nums
```

### 学到的东西
1. 感觉如果按照good solution的逻辑，如果第一位不是零，那么left都会直接加1，right则会按照for循环的逻辑往后遍历。反正只要保证零在后边就行了，前面的正数是否还按照原来的顺序并不重要。只要不断地将right遍历到的非零项移动到list的零项的左侧就好了，right指针一定是快于或等于left指针的，因为当right遍历到0项的时候并不会触发交换和left指针进一位。
2. [作者解释](https://leetcode.com/problems/move-zeroes/solutions/5246963/video-two-pointer-solution/?envType=study-plan-v2&envId=top-100-liked)

## Implement Trie (Prefix Tree)
[link](https://leetcode.com/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
我的答案占用的计算资源相对较多，还是参考good solution的思想
```
class Trie:

    def __init__(self):
        self.dict = {}
        

    def insert(self, word: str) -> None:
        self.dict[word] = 0
        

    def search(self, word: str) -> bool:
        return word in self.dict
        

    def startsWith(self, prefix: str) -> bool:
        for i in self.dict.keys():
            if prefix == i[0:len(prefix)]:
                return True

        return False
```

### good solution 
```
class Trie:

    def __init__(self):
        self.root={}
        
    def insert(self, word: str) -> None:

        cur=self.root

        for letter in word:
            if letter not in cur:
                cur[letter]={}
            cur=cur[letter]

        cur['*']=''

    def search(self, word: str) -> bool:

        cur=self.root
        for letter in word:
            if letter not in cur:
                return False
            cur=cur[letter]

        return '*' in cur
        
    def startsWith(self, prefix: str) -> bool:

        cur=self.root
        for letter in prefix:
            if letter not in cur:
                return False
            cur=cur[letter]

        return True
```

### 学到的东西
1. good solution的想法相当于是将word的每个字母都作为一个key, 同时value初始化为一个dictionary并存储下一个遍历到的字母，也就是说构造了一个嵌套的结构来存储输入的word。
2. 这样做的好处就是在进行search和startsWith时可以很清晰地遍历每个字母。

## Next Permutation
[link](https://leetcode.com/problems/next-permutation/description/?envType=study-plan-v2&envId=top-100-liked)

### my solution
没做出来，没想到做题的逻辑是什么，学习good solution的解题逻辑

### good solution
```
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        n = len(nums)
        i = n - 2
        
        # Step 1: Find the breakpoint
        while i >= 0 and nums[i] >= nums[i + 1]:
            i -= 1
        
        if i >= 0:
            # Step 2: Find the smallest element larger than nums[i]
            j = n - 1
            while nums[j] <= nums[i]:
                j -= 1
            # Swap nums[i] and nums[j]
            nums[i], nums[j] = nums[j], nums[i]
        
        # Step 3: Reverse the subarray to the right of i
        nums[i + 1:] = reversed(nums[i + 1:])
```

### 学到的东西
1. good solution的[作者解释](https://leetcode.com/problems/next-permutation/?envType=study-plan-v2&envId=top-100-liked)
2. 我没想到解决这个题目的思路，其实就是从右往左寻找第一个降序位置。比如[1,2,4,3],则我们要找到的第一个降序位置的对应值就是2，因为2比4小。这个降序位置的值可以被视为一个breakpoint。如果找不到降序位置的值，则说明整个数列从右往左是完全升序排列，这样就说明整个序列已经是最大的排列等级了，例如[4,3,2,1],那么下一步就直接反转成[1,2,3,4]
3. 然后从右到这个breakpoint的位置，寻找一个比这个breakpoint位置的值大的最小值，将这个比breakpoint位置的值大的最小值和这个breakpoint位置的值进行替换。完成替换操作后，将breakpoint位置右边的子array进行reverse操作。如[1,2,4,3]替换成[1,3,4,2],然后子序列[4,2]再反转成[2,4]最后形成[1,3,2,4].
4. 反转操作python中有专门针对的函数名为reversed()!!!!记住！！！！！